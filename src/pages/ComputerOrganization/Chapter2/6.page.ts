import { img, p, precode, section } from '@src/components/@write'
import pic2_6_1 from './2-6-1.jpg'
import pic2_6_2 from './2-6-2.jpg'
import pic2_6_3 from './2-6-3.jpg'
import pic2_6_4 from './2-6-4.jpg'
import pic2_6_5 from './2-6-5.jpg'
import pic2_6_6 from './2-6-6.jpg'
import pic2_6_7 from './2-6-7.jpg'
import pic2_6_8 from './2-6-8.jpg'
import pic2_6_9 from './2-6-9.jpg'
import pic2_6_10 from './2-6-10.jpg'
import pic2_6_11 from './2-6-11.jpg'
import pic2_6_12 from './2-6-12.jpg'
import pic2_6_13 from './2-6-13.jpg'
import pic2_6_14 from './2-6-14.jpg'
import pic2_6_15 from './2-6-15.jpg'
import pic2_6_16 from './2-6-16.jpg'
import pic2_6_17 from './2-6-17.jpg'
import pic2_6_18 from './2-6-18.jpg'
import pic2_6_19 from './2-6-19.jpg'
import pic2_6_20 from './2-6-20.jpg'
import pic2_6_21 from './2-6-21.jpg'
import pic2_6_22 from './2-6-22.jpg'
const title = '2.6　分析应用题'
const page = section(title)(
    section('1.实现下列各数的转换。')(
        p`（1）（25.8125）10=（？）2=（？）8=（？）16`,
        p`（2）（101101.011）2=（？）10=（？）8=（？）16=（？）8421`,
        p`（3）（0101 1001 0110.0011）8421=（？）10=（？）2=（？）16`,
        p`（4）（4E.C）16=（？）10=（？）2`,
        section('分析解答')(
            p`（1）（25.8125）10=（11001.1101）2=（31.64）8=（19.D）16`,
            p`（2）（101101.011）2=（45.375）10=（55.3）8=（2D.6）16=（0100 0101.0011 0111 0101）8421`,
            p`（3）（0101 1001 0110.0011）8421=（596.3）10=（1001010100.010011…）2=（254.4…）16`,
            p`（4）（4E.C）16=（78.75）10=（100 1110.11）2`
        )
    ),
    section('2.假定机器数为 8 位（1 位符号，7 位数值），写出下列各二进制数的原码和补码表示。')(
        p`+0.1001，-0.1001，+1.0，-1.0，+0.010100，-0.010100，+0，-0`,
        section('分析解答')(p`上述各二进制数的原码和补码表示见表 2.1。`, img(pic2_6_1)('表 2.1　小数的原码和补码表示'))
    ),
    section('3.假定机器数为 8 位（1 位符号，7 位数值），写出下列各二进制数的补码和移码表示。')(
        p`+1001，-1001，+1，-1，+10100，-10100，+0，-0`,
        section('分析解答')(p`上述各二进制数的补码和移码表示见表 2.2。`, img(pic2_6_2)('表 2.2　整数的补码和移码表示'))
    ),
    section('4.若[x]补=1.x1x2x3x4，小数点前面一位为符号位，当 x1x2x3x4满足什么条件时，x<-1/2 成立？')(
        section('分析解答')(
            p`补码的编码规则是：「正数的补码，其符号位为 0，数值位不变；负数的补码，其符号位为 1，数值位各位取反，末尾加 1」。从形式上来看，[x]补的符号位为 1，故 x 一定是负数。因此，绝对值越大，数值越小，因而要满足 x<-1/2，则 x 的绝对值必须大于 1/2。因此，x1必须为 0，x2x3x4至少有一个为 1，这样，各位取反末尾加 1 后，x1一定为 1，x2x3x4中至少有一个为 1，使得 x 的绝对值保证大于 1/2。因此，x1必须为 0，x2x3x4至少有一个为 1。`
        )
    ),
    section('5.已知[x]补，求 x。')(
        p`（1）[x]补=11100001`,
        p`（2）[x]补=10000000`,
        p`（3）[x]补=01111111`,
        p`（4）[x]补=11111111`,
        section('分析解答')(p`（1）x=-1 1111B=-31`, p`（2）x=-1000 0000B=-128`, p`（3）x=111 1111B=31`, p`（4）x=-0000 0001B=-1`)
    ),
    section('6.将以下十进制数表示成无符号整数时至少需要几个二进位？')(
        p`156，820，1200，4503`,
        section('分析解答')(
            p`27-1<156<28-1，故至少需要 8 位。`,
            p`29-1<820<210-1，故至少需要 10 位。`,
            p`210-1<1200<211-1，故至少需要 11 位。`,
            p`212-1<4503<213-1，故至少需要 13 位。`
        )
    ),
    section(
        '7.假定某程序中定义了三个变量 x、y 和 z，其中 x 和 z 为 int 型，y 为 short 型。当 x=-258，y=-20 时，执行赋值语句 z=x-y 后，存放 z 的寄存器中的内容是多少？'
    )(
        section('分析解答')(
            p`现代计算机中的带符号整数都是用补码表示的，因此，本题可以直接计算 z 的值，然后将 z 的补码形式求出来，也可以先将 x 和 y 的补码求出，再通过补码加法求出 z 的补码表示。显然，前一种思路效率较高。对于前一种思路，执行赋值语句后，z=-238，因此，问题就变成了求-238 的补码表示，其结果为[-000 0000 0000 0000 0000 0000 0000 1110 1110]补=1111 1111 1111 1111 1111 1111 0001 0010=FFFF FF12H。`
        )
    ),
    section(
        '8.假定 sizeof（int）=4，表 2.3 中第一列给出了 C 语言程序中的关系表达式，请参照已有表栏内容完成表中后三栏内容的填写，并对其中的关系表达式「2147483647<（int）2147483648U」的结果进行说明。'
    )(
        img(pic2_6_3)('表 2.3　关系表达式的运算结果'),
        section('分析解答')(
            p`按照题目要求填表如下（见表 2.4）。`,
            img(pic2_6_4)('表 2.4　与表 2.3 对应的关系表达式的运算结果'),
            p`8 个关系表达式运算结果分别是 1、1、0、1、0、0、1、1，其中 1 表示「真」，0 表示「假」。关系表达式「2147483647<（int）2147483648U」的结果为「假」。因为小于号右边的「2147483648U」是一个带后缀 U 的整数，因而是无符号整数，其机器数为「100…0」（1 后面跟 31 个 0），其值为 231。强制类型转换为 int 型后，其真值为-231，即「-2147483648」，显然「2147483647<-2147483648」是不成立的，也即结果为「假」。`
        )
    ),
    section(
        '9.以下是一个 C 语言程序，用来计算一个数组 a 中每个元素的和。当参数 len 为 0 时，返回值应该是 0，但在执行时，却发生了存储器访问异常。请问这是什么原因造成的，并说明程序应该如何修改。'
    )(
        precode(`1　float sum_elements (float a[], unsigned len)
2　{
3　    int i;
4　    float  result = 0;
5
6　    for (i = 0; i <= len-1; i++)
7　        result += a[i];
8　    return result;
9　}
`)(),
        section('分析解答')(
            p`存储器访问异常是由于对数组 a 访问时产生了越界或越权错误而造成的。循环变量 i 是 int 型，而 len 是 unsigned 型，当 len 为 0 时，执行 len-1 的结果为 32 个 1，是最大可表示的 32 位无符号数，任何无符号数都比它小，使得循环体被不断执行，导致数组访问越界或越权，因而发生了存储器访问异常。应当将参数 len 声明为 int 型。`
        )
    ),
    section('10.考虑下列 C 语言程序代码：')(
        precode(`int i =65535;
short si = (short)i;
int j = si;
`)(),
        p`假定上述程序段在某 32 位机器上执行，sizeof（int）=4，则变量 i、si 和 j 的值分别是多少？为什么？`,
        section('分析解答')(
            p`在一台 32 位机器上执行上述代码段时，i 为 32 位补码表示的定点整数，第 2 行要求强行将一个 32 位带符号数截断为 16 位带符号整数，65535 的 32 位补码表示为 0000 FFFFH，截断为 16 位后变成 FFFFH，它是-1 的 16 位补码表示，因此 si 的值是-1。再将该 16 位带符号整数扩展为 32 位时，就变成了 FFFF FFFFH，它是-1 的 32 位补码表示，因此 j 的值也为-1。也就是说，i 的值原来为 65535，经过截断、再扩展后，其值变成了-1。`
        )
    ),
    section(
        '11.某字长为 8 位的计算机中，x 和 y 为无符号整数，已知 x=68，y=80，x 和 y 分别存放在寄存器 A 和 B 中。请回答下列问题（要求最终用十六进制表示二进制序列）。'
    )(
        p`（1）寄存器 A 和 B 中的内容分别是什么？`,
        p`（2）若 x 和 y 相加后的结果存放在寄存器 C 中，则寄存器 C 中的内容是什么？运算结果是否正确？加法器最高位的进位 Cout 是什么？零标志 ZF 和进位标志 CF 各是什么？`,
        p`（3）若 x 和 y 相减后的结果存放在寄存器 D 中，则寄存器 D 中的内容是什么？运算结果是否正确？加法器最高位的进位 Cout 是什么？零标志 ZF 和借位标志 CF 各是什么？`,
        p`（4）无符号整数加/减运算时，加法器最高位进位 Cout 的含义是什么？它与进/借位标志 CF 的关系是什么？`,
        section('分析解答')(
            p`（1）x=68=0100 0100 B=44H；y=80=0101 0000 B=50H，所以，寄存器 A 和 B 中的内容分别是 44H 和 50H。`,
            p`（2）x+y=0100 0100+0101 0000=（0）1001 0100=94H，所以，寄存器 C 中的内容为 94H，对应的真值为 148，运算结果正确。加法器最高位的进位 Cout 为 0。因为结果不为 0，所以 ZF=0；进位标志 CF=Cout=0。`,
            p`（3）x-y=x+[-y]补=0100 0100+1011 0000=（0）1111 0100=F4H，所以，寄存器 D 中的内容为 F4H，对应的真值为 244，运算结果不正确，这是由相减结果为负数造成的。加法器最高位的进位 Cout 为 0。因为结果不为 0，所以 ZF=0；借位标志为 CF=Cout⊕1=1。`,
            p`（4）在加法器中进行无符号整数加法运算时，若加法器最高位进位 Cout=1，则表示实际结果大于最大可表示数 255，即溢出，此时 CF=1。因此，对于无符号整数加运算来说，CF=1 表示溢出；在加法器中进行无符号整数减法运算时，若加法器最高位进位 Cout=1，则表示被减数大于减数，反之被减数小于减数。因此，在无符号数相加时，CF 就等于 Cout，表示进位；在无符号数相减时，将最高进位 Cout 取反来作为借位标志 CF，即 CF=Cout⊕1=Cout，CF=1 表示有借位。`
        )
    ),
    section(
        '12.假设某字长为 8 位的计算机中，带符号整数采用补码表示，x=-68，y=-80，x 和 y 分别存放在寄存器 A 和 B 中。请回答下列问题（要求最终用十六进制表示二进制序列）。'
    )(
        p`（1）寄存器 A 和 B 中的内容分别是什么？`,
        p`（2）若 x 和 y 相加后的结果存放在寄存器 C 中，则寄存器 C 中的内容是什么？运算结果是否正确？加法器最高位的进位 Cout 是什么？溢出标志 OF、符号标志 SF 和零标志 ZF 各是什么？`,
        p`（3）若 x 和 y 相减后的结果存放在寄存器 D 中，则寄存器 D 中的内容是什么？运算结果是否正确？此时，加法器最高位的进位 Cout 是什么？溢出标志 OF、符号标志 SF 和零标志 ZF 各是什么？`,
        p`（4）对于带符号整数的减法运算，能否直接根据 CF 的值对两个带符号整数的大小进行比较？`,
        section('分析解答')(
            p`（1）[-68]补=[-1000100]补=1011 1100B=BCH，[-80]补=[-1010000]补=1011 0000B=B0H，所以，寄存器 A 和 B 中的内容分别是 BCH 和 B0H。`,
            p`（2）[x+y]补=[x]补+[y]补=1011 1100 B+1011 0000 B=（1）0110 1100B=6CH，最高位前面的一位 1 被丢弃，因此，寄存器 C 中的内容为 6CH，对应的真值为 +108，结果不正确。加法器最高位向前面的进位 Cout 为 1。溢出标志位 OF 可采用以下任意一条规则判断得到。规则 1：若两个加数的符号位相同，但与结果的符号位相异，则溢出；规则 2：若最高位上的进位和次高位上的进位不同，则溢出。对于本题，通过这两个规则都判断出结果溢出，因此溢出标志 OF 为 1，说明寄存器 C 中的内容不是正确的结果。x+y 的正确结果应是-68+（-80）=-148，而运算的结果为 108，两者不等。这是因为 x+y 的值（即-148）小于 8 位补码可表示的最小值（即-128），也即结果发生了溢出；结果的第一位（最高位）0 为符号标志位 SF，即 SF=0，表示结果为正数；因为结果不为 0，所以零标志 ZF=0。`,
            p`（3）[x-y]补=[x]补+[-y]补=1011 1100 B+0101 0000B=（1）00001100B=0CH，最高位前面的一位 1 被丢弃，因此，寄存器 D 中的内容为 0CH，对应的真值为 +12，结果正确。加法器最高位向前面的进位 Cout 为 1。两个加数的符号位相异一定不会溢出，因此溢出标志 OF=0，说明寄存器 D 中的内容是真正的结果；结果的第一位（最高位）0 为符号标志位 SF，即 SF=0，表示结果为正数；因为结果不为 0，所以零标志 ZF=0。`,
            p`（4）对于带符号整数的减法运算，无法直接根据 CF 的值判断两个带符号整数的大小。例如，对于 x=-68，y=80，[x-y]补=[x]补+[-y]补=1011 1100 B+1011 0000B=（1）0110 1100B，得到的 Cout 为 1，因此，CF=Cout⊕1=0，表示没有借位，推断出被减数应该大于减数，即-68>80，显然这是不正确的，因此带符号运算中不考虑 CF 标志。`
        )
    ),
    section(
        '13.某计算机标志寄存器包含 4 个标志位：CF—进/借位标志；OF—溢出标志；SF—符号标志；ZF—零标志。请说明在无符号数和带符号整数两种情况下，以下各种比较运算的逻辑判断表达式。'
    )(
        p`① 等于；② 大于；③ 小于；④ 大于等于；⑤ 小于等于。`,
        section('分析解答')(
            p`要比较两个数的大小，通常对这两个数先做减法，根据相减的结果生成相应的标志位，最后根据标志位判断大小。在无符号数相减时，一般不考虑 SF 和 OF 标志；在带符号整数相减时，一般不考虑 CF 标志。`,
            p`假设被减数的机器数为 X，减数的机器数为 Y，则在加法器中计算两数的差时，计算公式为：X-Y=X+（-Y）补。以下举两个例子来说明。`,
            p`假定 X=1001，Y=1100，则在 4 位加法器中执行以下运算：1001-1100=1001+0100=（0）1101。若是无符号数比较，则是 9 和 12 相比，显然，ZF=0，CF=1；若是带符号整数（补码表示），则是-7 和-4 比较，显然，ZF=0，OF=0，SF=1。`,
            p`假定 X=1001，Y=0100，则在 4 位加法器中执行以下运算：1001-0100=1001+1100=（1）0101。若是无符号数比较，则是 9 和 4 相比，显然，ZF=0，CF=0；若是带符号整数，则是-7 和 4 比较，显然，ZF=0，OF=1，SF=0。`,
            p`下面分别说明无符号数和带符号整数两种情况下各种比较运算的逻辑判断表达式。`,
            p`1) 无符号数情况`,
            p`（1）等于：相减后结果为零，即 F=ZF。`,
            p`（2）大于：没有借位且相减后不为 0，即 F=CF·ZF=CF+ZF。`,
            p`（3）小于：有借位且相减后不为 0，即 F=CF·ZF。`,
            p`（4）大于等于：没有借位或相减后结果为 0，即 F=CF+ZF。`,
            p`（5）小于等于：有借位或相减后结果为 0，即 F=CF+ZF。`,
            p`2) 带符号整数情况`,
            p`（1）等于：相减后结果为零，即 F=ZF。`,
            p`（2）大于：相减后结果不为 0，并且，不溢出时为正，溢出时为负。即 F=ZF·（SF⊕OF）。`,
            p`（3）小于：相减后结果不为 0，并且，不溢出时为负，溢出时为正。即 F=ZF·（SF⊕OF）。`,
            p`（4）大于等于：相减后结果为 0，或者，不溢出时为正，溢出时为负。即 F=ZF+（SF⊕OF）。`,
            p`（5）小于等于：相减后结果为 0，或者，不溢出时为负，溢出时为正。即 F=ZF+（SF⊕OF）。`,
            p`可以对照上述判断表达式，验证上述例子。无符号整数 9 和 12 是小于关系，相减后得到的标志 ZF=0，CF=1，故 F=CF·ZF=1。无符号整数 9 和 4 是大于关系，相减后得到的标志 CF=0，ZF=0，故 F=CF·ZF=1。带符号整数-7 和-4 是小于关系，相减后得到的标志 ZF=0，OF=0，SF=1，故 F=ZF·（SF⊕OF）=1。带符号整数-7 和 4 是小于关系，相减后得到的标志 ZF=0，OF=1，SF=0，故 F=ZF·（SF⊕OF）=1。`
        )
    ),
    section('14.填写表 2.5，注意对比无符号数和带符号整数的乘法结果，以及截断操作前、后的结果。')(
        img(pic2_6_5)('表 2.5　题 14 用表'),
        section('分析解答')(
            p`根据无符号数乘法运算和补码乘法运算算法，填写表 2.5 后，得到表 2.6。`,
            img(pic2_6_6)('表 2.6　题 14 中填入结果后的表'),
            p`对表 2.6 中的结果分析如下：`,
            p`① 对于两个相同的机器数，作为无符号数进行乘法运算和作为带符号整数进行乘法运算，因为其所用的乘法算法不同，所以，乘积的机器数可能不同。但是，从表中看出，截断后的乘积是一样的，也即不同的仅是乘积中的高 n 位，而低 n 位完全一样。`,
            p`② 对于 n 位乘法运算，无论是无符号数乘法还是带符号整数乘法，若截取 2n 位乘积的低 n 位作为最终的乘积，则都有可能结果溢出，即 n 位数字无法表示正确的乘积。虽然表中给出的带符号整数乘积截断后都没有发生溢出，但实际上还是存在溢出的情况，例如，011×011=001001，截断后 011×011=001，显然截断后的结果发生了溢出。`,
            p`③ 表中加粗的地方是截断后发生溢出的情况。可以看出，对于无符号整数乘法，若乘积中高 n 位为全 0，则截断后的低 n 位乘积不发生溢出；否则溢出。对于带符号整数乘法，若高 n 位中的每一位都等于低 n 位中的第一位，则截断后的低 n 位乘积不发生溢出；否则溢出。`
        )
    ),
    section('15.考虑以下 C 语言程序代码：')(
        precode(`                int   func1 (unsigned word)
                {
                    return  (int) (( word <<24) >> 24);
                }
                int   func2 (unsigned word)
                {
                    return  ( (int) word <<24 ) >> 24;
                }`)(),
        p`假设在一个 32 位机器上执行这些函数，sizeof（int）=4。说明函数 func1 和 func2 的功能，填写表 2.7，并给出对表中「异常」数据的说明。`,
        img(pic2_6_7)('表 2.7　题 15 用表'),
        section('分析解答')(
            p`函数 func1 的功能是把无符号数高 24 位清零（左移 24 位再逻辑右移 24 位），结果一定是正的带符号整数；而函数 func2 的功能是把无符号数的高 24 位都变成和第 25 位一样，因为左移 24 位后左边第一位变为原来的第 25 位，然后进行算术右移，高位补符号，即高 24 位都变成和原来第 25 位相同。`,
            p`根据程序执行的结果填表（见表 2.8），其中机器数用十六进制表示。`,
            img(pic2_6_8)('表 2.8　题 15 中填入结果后的表'),
            p`因为逻辑左移和算术左移的结果完全相同，所以，函数 func1 和 func2 中第一步左移 24 位得到的结果完全相同，所不同的是右移 24 位后的结果不同。`,
            p`上述表 2.8 中，加粗数据是一些「异常」结果。当 w=128 和 255 时，第 25 位正好是 1，因此函数 func2 执行的结果为一个负数，即出现了「异常」。当 w=256 时，低 8 位为 00，高 24 位为非 0 值，左移 24 位后使得有效数字被移出，因而发生了「溢出」，使得出现了「异常」结果 0。`
        )
    ),
    section(
        '16.以下是两段 C 语言代码，函数 arith（）是直接用 C 语言写的，而 optarith（）是对 arith（）函数以某个确定的 M 和 N 编译生成的机器代码反编译生成的。根据 optarith（），推断函数 arith（）中 M 和 N 的值各是多少？'
    )(
        precode(`                #define         M
                #define         N
                int     arith(int x,  int y)
                {
                    int  result = 0 ;
                    result = x*M + y/N;
                    return result;
                }

                int optarith ( int x,  int y)
                {
                    int  t = x;
                    x << = 4;
                    x- = t;
                    if ( y < 0 )  y+= 3;
                    y>>=2;
                    return x+y;
                }`)(),
        section('分析解答')(
            p`对反编译结果进行分析，可知：对于 x，指令机器代码中有一条「x 左移 4 位」指令，即：x=16x，然后有一条「减法」指令，即 x=16x-x=15x，根据源程序知 M=15；对于 y，有一条「y 右移 2 位」指令，即 y=y/4，根据源程序知 N=4。但是，当 y<0 时，对于有些 y，执行 y>>2 后的值并不等于 y/4。例如，当 y=-1 时，在反编译函数 optarith 中执行 y>>2 时，因为-1 的机器数为全 1，左移两位后还是全 1，也即-1>>2=-1，结果为-1；而原函数 arith（）中执行 y/4 时，因为-1/4=0，得到结果为 0。`,
            p`对于带符号整数来说，采用算术右移时，高位补符号，低位移出。因此，当符号位为 0 时，与无符号整数相同，采用移位方式和直接相除得到的商完全一样。当符号位为 1 时，若低位移出的是非全 0，则说明不能整除。例如，对于-3/2，假定补码位数为 4，则进行算术右移操作 1101>>1=1110.1B（小数点后面部分移出）后得到的商为-2，而精确商是-1.5，即整数商应为-1。显然，算术右移后得到的商比精确商少了 0.5，相当于朝-∞ 方向进行了舍入，而不是朝零方向舍入。因此，这种情况下，移位得到的商与直接相除得到的商不一样，需要进行校正。`,
            p`校正的方法是，对于带符号整数 x，若 x<0，则在右移前，先将 x 加上偏移量（2k-1），然后再右移 k 位。例如，上述函数 optarith（）中，在执行 y>>2 之前加了一条语句「if（y<0）　y+=3；」，以对 y 进行校正。`
        )
    ),
    section('17.考虑以下 C 语言程序代码：')(
        precode(`                int  func1(unsigned short si)
                {
                    return (si*256) ;
                }
                int  func2(unsigned short si)
                {
                    return (si/256) ;
                }
                int  func3(unsigned short si)
                {
                    return (((short) si*256)/256);
                }
                int  func4(unsigned short si)
                {
                    return (short) (( si*256)/256);
                }`)(),
        p`请回答下列问题：`,
        p`（1）假设计算机硬件不提供乘除运算功能，能否用移位运算实现上述函数功能？函数 func1、func2、func3 和 func4 得到的结果各有什么特征？`,
        p`（2）填写表 2.9（要求机器数用十六进制表示），并对表中的「异常」数据进行分析。`,
        img(pic2_6_9)('表 2.9　题 17 用表'),
        section('分析解答')(
            p`（1）编译器在处理变量与常数相乘时，往往以移位、加法和减法的组合运算来代替乘法运算。例如，对于表达式 x*20，编译器可以利用 20=16+4=24+22，将 x*20 转换为（x<<4）+（x<<2），这样，一次乘法转换成了两次移位和一次加法。不管是无符号整数还是带符号整数的乘法，即使乘积溢出时，利用移位和加减运算组合的方式得到的结果都是和采用直接相乘的结果是一样的。`,
            p`为了缩短除法运算的时间，编译器在处理一个变量与一个 2 的幂次形式的整数相除时，常采用右移运算来实现。无符号整数除法采用逻辑右移方式，带符号整数除法采用算术右移方式。两个整数相除，结果也一定是整数，在不能整除时，其商采用朝零方向舍入的方式，也就是截断方式，即将小数点后的数直接去掉，例如，7/3=2，-7/3=-2。`,
            p`对于无符号整数来说，采用逻辑右移时，高位补 0，低位移出，因此，移位后得到的商的值只可能变小而不会变大，即商朝零方向舍入。因此，不管是否能够整除，采用移位方式和直接相除得到的商完全一样。但是，对于带符号整数 x 来说，如题 16 的分析解答中所说的那样，当计算 x/2k时，若 x<0，则不能直接将 x 算术右移 k 位，而应该先将 x 加上偏移量（2k-1），然后再算术右移 k 位。`,
            p`因为 256=28，所以题目给出的函数中的乘、除运算可以分别用左、右移运算来实现。可用「左移 8 位」代替「乘 256」的操作，用「右移 8 位」代替「除以 256」的操作。func1（si）相当于将 si 逻辑左移 8 位，结果的最后 8 位都为 0；func2（si）相当于将 si 逻辑右移 8 位，结果的范围在 0 和 255 之间；func3（si）相当于将 si 先算术左移 8 位，再算术右移 8 位，所以结果的范围在-128 和 127 之间；func4（si）相当于将 si 先逻辑左移 8 位，再逻辑右移 8 位，最后以带符号整数类型返回。因为最后是逻辑右移，高位补 0，所以，返回的总是正数，结果的范围在 0 和 255 之间。`,
            p`（2）函数 func1、func2、func3 和 func4 的执行结果见表 2.10。`,
            img(pic2_6_10)('表 2.10　题 17 中填入结果后的表'),
            p`上述表 2.10 中，加粗数据是一些「异常」结果。当 si=256 时，由于 256×si=65536，因此用 16 位无符号数无法表示实际结果，导致 func1（si）、func3（si）和 func4（si）都为 0；当 si=65535 时，由于 256×si 溢出，导致 func1、func3 和 func4 的函数值出现了「异常」结果；当 si=128 时，因为 256×128=32768，超过了 short 型数据的最大表示范围，发生溢出，其结果与 128<<8 的操作结果一样，机器数都是 8000H，其真正的值为-32768，再除以 256，结果为-128，与对 8000H 算术右移 8 位得到的结果 FF80H（值为-128）完全一样；当 si=255 时，因为 256×255=65280，超过了 short 型数据的最大表示范围，发生溢出。因此，左移 16 位后得到乘积 FF00H（真值为-256），其第一位（符号位）为 1，即乘积变成了负数，反映出乘积是一个溢出值。因此再除以 256，结果应该是-1，显然，通过算术右移 8 位得到的结果 FFFFH，其值也是-1。`
        )
    ),
    section('18.下列几种情况所能表示的数的范围是什么？')(
        p`（1）16 位无符号整数。`,
        p`（2）16 位原码定点小数。`,
        p`（3）16 位补码定点整数。`,
        p`（4）下述格式的浮点数（基数为 2，移码的偏置常数为 128，规格化尾数，不考虑隐藏位）。`,
        img(pic2_6_11)(),
        section('分析解答')(
            p`（1）16 位无符号整数范围为 0～216-1，即 0～65535。`,
            p`（2）16 位原码定点小数表示的范围为-（1-2-15）～+（1-2-15）。`,
            p`（3）16 位补码定点整数表示的范围为-215～+（215-1），即-32768～+32767。`,
            p`（4）规格化浮点数的表示范围如下。`,
            p`最大正数：+0.1111111B×211111111B=+（1-2-7）×2127。`,
            p`最小正数：+0.1000000B×200000000B=+2-1×2-128=+2-129。`,
            p`最大负数：-0.1000000B×200000000B=-2-1×2-128=-2-129。`,
            p`最小负数：-0.1111111B×211111111B=-（1-2-7）×2127。`,
            p`由于原码是关于原点对称的，所以，浮点数的表示范围是关于原点对称的。`,
            p`对于非规格化浮点数，其最小正数和最大负数的尾数形式为 ±0.0000001，最小正数和最大负数的值为 ±2-7×2-128=±2-135。`
        )
    ),
    section('19.设某浮点数格式为：')(
        img(pic2_6_12)(),
        p`其中，移码的偏置常数为 16，补码采用一位符号位和 6 位数值位，基数为 4，规格化尾数，不考虑隐藏位。`,
        p`（1）用这种格式表示下列十进制数：+1.625，-0.125，+20，-9/16。`,
        p`（2）写出该格式浮点数的表示范围。`,
        section('分析解答')(
            p`（1）+1.625=+1.1010B=（+0.122）4×41，故阶码为：1+16=17=10001B，尾数为四进制数 +0.122 的补码，即 0.011010B，因此，+1.625 表示为 010001011010。`,
            p`-0.125=-0.0010B=（-0.200）4×4-1，故阶码为：-1+16=15=01111B，尾数为四进制数-0.200 的补码，即 1.100000B，因此，-0.125 表示为 101111100000。`,
            p`+20=+10100B=（+0.110）4×43，故阶码为：3+16=19=10011B，尾数为四进制数 +0.110 的补码，即 0.010100B，因此，+20 表示为 010011010100。`,
            p`-9/16=-0.1001B=（-0.210）4×40，故阶码为：0+16=16=10000B，尾数为四进制数-0.210 的补码，即 1.011100B，因此，-9/16 表示为 110000011100。`,
            p`（2）规格化浮点数的表示范围如下。`,
            p`最大正数：+0.111111B×411111B=（+0.333）4×415。`,
            p`最小正数：+0.010000B×400000B=（+0.100）4×4-16=+4-17。`,
            p`最大负数：-0.010000B×400000B=（-0.100）4×4-16=-4-17。`,
            p`最小负数：-1.000000B×411111B=（-1.000）4×415=-415。`,
            p`由于补码表示的尾数不是关于原点对称的，所以，浮点数的表示范围不是相对于原点对称的。`
        )
    ),
    section('20.以 IEEE 754 单精度浮点数格式表示下列十进制数，要求将结果写成十六进制形式。')(
        p`+1.625，-0.125，+20，-9/16`,
        section('分析解答')(
            p`+1.625=+1.101B×20，所以，符号 s=0，阶码 e=0+127=01111111B，尾数的小数部分 f=0.101B，因此，+1.625 用 IEEE 754 单精度浮点数格式表示为 00111111110100000000000000000000，用十六进制形式表示为 3FD00000H。`,
            p`-0.125=-0.001B=-1.0B×2-3，所以，符号 s=1，阶码 e=-3+127=01111100B，尾数的小数部分 f=0.0B，因此，-0.125 用 IEEE 754 单精度浮点数格式表示为 10111110000000000000000000000000，用十六进制形式表示为 BE000000H。`,
            p`+20=+10100B=+1.01B×24，所以，符号 s=0，阶码 e=4+127=10000011B，尾数的小数部分 f=0.01B，因此，+20 用 IEEE 754 单精度浮点数格式表示为 01000001101000000000000000000000，用十六进制形式表示为 41A00000H。`,
            p`-9/16=-0.1001B=-1.001B×2-1，所以，符号 s=1，阶码 e=-1+127=01111110B，尾数的小数部分 f=0.001B，因此，-9/16 用 IEEE 754 单精度浮点数格式表示为 10111111000100000000000000000000，用十六进制形式表示为 BF100000H。`
        )
    ),
    section('21.以 IEEE 754 单精度浮点数格式表示下列十进制数，要求将结果写成十六进制形式。')(
        p`+1.75，+19，-1/8，258`,
        section('分析解答')(
            p`+1.75=+1.11B=1.11B×20，故阶码为 0+127=01111111B，数符为 0，尾数为 1.110…0，小数点前为隐藏位，所以 +1.7 表示为 00111111111000000000000000000000，用十六进制表示为 3FE00000H。`,
            p`+19=+10011B=+1.0011B×24，故阶码为 4+127=10000011B，数符为 0，尾数为 1.00110…0，所以 +19 表示为 01000001100110000000000000000000，用十六进制表示为 41980000H。`,
            p`-1/8=-0.125=-0.001B=-1.0×2-3，阶码为-3+127=01111100B，数符为 1，尾数为 1.0…0，所以-1/8 表示为 10111110000000000000000000000000，用十六进制表示为 BE000000H。`,
            p`258=100000010B=1.0000001B×28，故阶码为 8+127=10000111B，数符为 0，尾数为 1.0000001，所以 258 表示为 01000011100000010000000000000000，用十六进制表示为 43810000H。`
        )
    ),
    section(
        '22.表 2.11 给出了有关 IEEE 754 浮点格式表示中一些重要的非负数的取值，表中已经有最大规格化数的相应内容，要求填入其他浮点数格式的相应内容。'
    )(
        img(pic2_6_13)('表 2.11　题 22 用表'),
        section('分析解答')(p`根据 IEEE 754 浮点格式，填表 2.11，结果见表 2.12。`, img(pic2_6_14)('表 2.12　表 2.11 填入结果后的样式'))
    ),
    section('23.假定一个 float 型变量 x 的机器数为 45100000H，则变量 x 的值是多少？')(
        section('分析解答')(
            p`float 型变量的机器数对应 IEEE754 单精度浮点数格式，因此，将 45100000H 展开为 32 位机器数：01000101000100000000000000000000 后，得到其符号位为 0；阶码为 10001010B，其阶（指数）为 10001010B-127=138-127=11；尾数的值为 1.001B=1.125。因而 x 的数值为 +1.125×211=2304。`
        )
    ),
    section(
        '24.设一个变量的值为 2049，要求分别用 32 位补码整数和 IEEE 754 单精度浮点格式表示该变量（结果用十六进制表示），并说明哪段二进制序列在两种表示中完全相同，为什么会相同？'
    )(
        section('分析解答')(
            p`2049=100000000001B=+1.00000000001B×211，用 32 位补码整数表示为 00000000000000000000100000000001，用十六进制形式表示为 00000801H；用 IEEE 754 单精度浮点数格式表示时，符号 s=0，阶码 e=11+127=10001010B，尾数的小数部分 f=0.00000000001B，因此，2049 用 IEEE 754 单精度浮点数格式表示为 01000101000000000001000000000000，用十六进制形式表示为 45001000H。`,
            p`在上述两种表示中，存在相同的二进制序列 00000000001。因为 2049 被转换为规格化浮点数后，有效数值部分中最前面的 1 被隐藏，其余数值部分为 00000000001，而 2049 的 32 位补码整数表示中保留了完整的有效数值部分，即最前面的 1 没有被隐藏，所以除了这个 1 之外，后面的二进制序列 00000000001 是相同的。`
        )
    ),
    section(
        '25.设一个变量的值为-2147483646，要求分别用 32 位补码整数和 IEEE 754 单精度浮点格式表示该变量（结果用十六进制表示），并说明哪种表示其值完全精确，哪种表示的是近似值。'
    )(
        section('分析解答')(
            p`-2147483646=-1111111111111111111111111111110B=-1.111111111111111111111111111110×230，32 位补码形式为：10000000000000000000000000000010（80000002H），IEEE 754 单精度格式为 11001111000000000000000000000000（CF00000000H），因为-2147483646 在-231～231-1 范围内，可用 32 位补码精确表示；对于 IEEE 754 单精度浮点数格式，最多只可表示 24 位有效二进位数字，而-2147483646 的有效二进位有 30 位，后面的有效二进位必须进行舍入，因而是近似表示。`
        )
    ),
    section(
        '26.假定变量 i、f 和 d 的数据类型分别为 int、float 和 double，sizeof（int）=4，已知 i=1234567890，f=1.23456789e10，要求给出以下各关系表达式的结果，并说明原因。'
    )(
        p`（1）i==（int）（float）i`,
        p`（2）i==（int）（double）i`,
        p`（3）f==（float）（int）f`,
        p`（4）f==（float）（double）f`,
        section('分析解答')(
            p`（1）结果为「假」。因为 float 类型采用 IEEE 754 单精度浮点数格式，尾数的小数部分只有 23 个二进位和一位隐藏位，共有 24 位有效位数，相应地，十进制有效位数为 7 位，而 i 中有 9 位有效位数，因而将 i 转换为 float 类型时会发生有效数字的丢失，再转换为 int 类型时，其值已经被改变了。`,
            p`（2）结果为「真」。因为 double 类型采用 IEEE 754 双精度浮点数格式，其有效位数为 52+1=53 个二进位，而 int 类型的有效位数有 31 个二进位，因而，对于任何一个 int 类型的变量，转换为 double 后，精度不会有任何损失，再转换回 int 类型时，其值不变。`,
            p`（3）结果为「假」。因为变量 f 的值超过了 int 类型可表示的最大值，因而将 f 转换为 int 类型后再转换回 float 类型时，其值已经改变。`,
            p`（4）结果是「真」。因为 double 类型的精度比 float 类型高，任何 float 类型变量的值转换为 double 后再转换回 float 类型时，其值不变。`
        )
    ),
    section(
        '27.假定一台 32 位字长的机器中带符号整数用补码表示，浮点数用 IEEE 754 标准表示，寄存器 R1 和 R2 的内容分别为 80200000H 和 00800000H。不同指令对寄存器进行不同的操作，因而，不同指令执行时寄存器内容对应的真值不同。假定执行下列运算指令时，操作数为寄存器 R1 和 R2 的内容，则 R1 和 R2 中操作数的真值分别为多少？'
    )(
        p`（1）无符号数加法指令。`,
        p`（2）带符号整数乘法指令。`,
        p`（3）单精度浮点数减法指令。`,
        section('分析解答')(
            p`寄存器 R1 的内容为 10000000001000000000000000000000，寄存器 R2 的内容为 00000000100000000000000000000000。`,
            p`（1）对于无符号数加法指令，R1 和 R2 的内容均被解释成无符号整数，即 R1 的真值为 80200000H，R2 的真值为 800000H，也即 R1 的真值为 231+221，R2 的真值为 223。`,
            p`（2）对于带符号整数乘法指令，R1 和 R2 的内容均被解释为补码整数，由最高位可知，R1 为负数，R2 为正数。R1 的真值为-01111111111000000000000000000000B=-7FE00000H；R2 的真值为 +800000H，也即 R1 的真值为-（231-221），R2 的真值为 223。`,
            p`（3）对于单精度浮点数减法指令，R1 和 R2 的内容均为 IEEE 754 单精度浮点数表示。由 R1 的内容可知，其符号位为 1，表示负数，阶码为 00000000，尾数部分为 01000000000000000000000，因为阶码为全 0 尾数为非 0 数，故 R1 是非规格化浮点数，其指数为-126，尾数为 0.01B，故 R1 表示的真值为-0.01B×2-126=-2-128。由 R2 的内容可知，其符号位为 0，表示正数，阶码为 00000001，尾数部分为 00000000000000000000000，R1 为规格化浮点数，其指数为 1-127=-126，尾数为 1.0B，故 R2 表示的真值为 +1.0×2-126=2-126。`
        )
    ),
    section(
        '28.IBM 370 的短浮点数格式中，总位数为 32 位，左边第一位（b0）为数符，随后 7 位（b1～b7）为阶码，用移码表示，偏置常数为 64，右边 24 位（b8～b31）为 6 位十六进制原码小数表示的尾数，规格化尾数形式为 0.x1x2x3x4x5x6，x1～x6为十六进制表示，最高位 x1为非 0 数，基为 16。若将十进制数-260.125 用该浮点数格式表示，则对应的机器数是什么？（要求用十六进制形式表示）'
    )(
        section('分析解答')(
            p`IBM 370 的短浮点数格式的尾数采用十六进制原码表示，即基数是 16。因此，在进行数据转换时，要先转化成十六进制形式，即-260.125=-000100000100.0010B=（-104.2）16=（-0.1042）16×163。由此可知，浮点数符号位应为 1，指数为 3，用 7 位移码表示为 64+3=1000011B，故前 8 位表示为 11000011，对应的十六进制为 C3H，尾数部分的 6 位十六进制数为 104200H，因此，对应的机器数为 C3104200H。`
        )
    ),
    section(
        '29.1991 年 2 月 25 日，海湾战争中，美国在沙特阿拉伯的达摩地区设置的爱国者导弹拦截伊拉克的飞毛腿导弹失败，致使飞毛腿导弹击中了美军的一个兵营，造成 28 名士兵死亡。这是由一个浮点数的精度问题造成的。爱国者导弹系统中有一个内置时钟，用计数器实现，每隔 0.1s 计数一次。程序用 0.1 乘以计数器的值得到以秒为单位的时间。0.1 的二进制表示是一个无限循环序列：0.00011[0011]…（方括弧中的序列是重复的）。请问：'
    )(
        p`（1）假定用一个类型为 float 的变量 x 来表示 0.1，则变量 x 在机器中的机器数是什么（要求写成十六进制形式）？绝对值 |x-0.1| 的值是什么（要求用十进制表示）？`,
        p`（2）爱国者系统启动时计数器的初始值为 0，并开始持续计数。假定当时系统运行了 200h，则程序计算的时间和实际时间的偏差为多少？如果爱国者根据飞毛腿的速度乘以它被侦测到的时间来预测位置，若飞毛腿的速度为 2000m/s，则预测偏差的距离为多少？`,
        section('分析解答')(
            p`（1）0.1=0.00011[0011]B=+1.10011001100110011001100B×2-4，float 类型采用 IEEE 754 单精度浮点数格式。符号位 s 为 0，阶码 e=127-4=123=01111011B，尾数的小数部分为 0.10011001100110011001100，因此，在机器中 float 型变量 x 表示为 00111101110011001100110011001100，用十六进制形式表示为 3DCC CCCCH。由于 float 类型的精度有限，只有 24 位有效位数，尾数从最前面的 1 开始一共只能表示 24 位，后面的有效数字全部被截断，故 x 与 0.1 之间的误差为：|x-0.1|=0.0000000000000000000000000001100[1100]B。这个值约等于 0.11B×2-27，大约为 5.59×10-9。`,
            p`（2）爱国者系统运行 200h 后，共计数 200×60×60×10=72×105次，因此，程序计算的时间和实际时间的偏差约为 5.59×10-9×72×105=0.0402s。预测偏差距离约为 2000m/s×0.0402s=80.4m。`
        )
    ),
    section(
        '30.假定浮点数的阶码用 m 位移码表示，偏置常数为 2m-1-1，规格化尾数的整数部分为 1，是隐藏位，小数部分有 n 位，用原码表示，基为 2，请回答下列问题。'
    )(
        p`（1）能用这种浮点数格式精确表示的最小正整数是多少？`,
        p`（2）不能用这种浮点数格式精确表示的最小正整数是多少？`,
        section('分析解答')(
            p`（1）能用这种浮点数格式表示的最小正整数为 1。`,
            p`（2）这种浮点数格式的有效位数为 n+1 位，因此，当某个正整数的有效位数大于 n+1 位时，则 n+1 位后的有效数字被截断，也即不能用这种浮点数格式精确表示。因此，不能用这种浮点数格式表示的最小正整数为 +10…01B（中间有 n 位 0），其值为 2n+1+1。`
        )
    ),
    section(
        '31.图 2.1a 是某个 C++ 程序，图 2.1b 是该程序的若干组执行结果。请根据 IEEE 754 标准的舍入规定对执行结果进行解释说明，并通过分析得出 float 变量的有效位数。'
    )(
        img(pic2_6_15)('图 2.1　源程序及其运行结果示例'),
        section('分析解答')(
            p`该程序的功能非常简单，就是从键盘上输入一个实数，赋给一个 float 型变量后再从屏幕上输出。从运行结果来看，61.419998 和 61.420002 是两个可表示数，两者之间相差 0.000004。当输入数据是一个不可表示数时，机器将其转换为最邻近的可表示数。`,
            p`目前几乎所有机器中 float 型变量都是采用 IEEE 754 单精度浮点数格式表示，其二进制有效位数为 24 位，因此能精确表示的十进制有效位数为 7 位。因为 61=111101B=1.11101B×25，如果将 float 型数据的规格化正数的表示范围以 2i（-126≤i≤127）为分割点划分成若干区间，61.419998 应该位于区间[25，26]，该区间相邻可表示数之间的间隔为 2-23×25=2-18=0.0000038…≈0.000004，从上述分析结果来看，该区间相邻两个可表示数之间的间隔就是 0.000004。因此，在 61.419998 前面的可表示数为 61.419994，后面的可表示数为 61.420002。`,
            p`显然，当输入 61.419997 和 61.419999 时，其最靠近的可表示数为 61.419998；而 61.420001 的最邻近可表示数为 61.420002；当输入为 61.42 时，从十进制形式 61.42000 来看，它位于可表示数 61.419998 和 61.420002 的中点，但是，实际上机器内部是按照二进制表示来判断的，从二进制表示形式来看，61.42 应该更靠近 61.419998，因此，61.42 对应输出的可表示数为 61.419998。`
        )
    ),
    section(
        '32.假定在一个程序中定义了变量 x、y 和 i，其中，x 和 y 是 float 型变量（用 IEEE 754 单精度浮点数表示），i 是 16 位 short 型变量（用补码表示）。程序执行到某一时刻，x=-130、y=7.25、i=130，它们都被写到了主存（按字节编址），其地址分别是&x、&y 和&i。请分别给出在大端机器和小端机器上变量 x、y 和 i 在内存的存放位置。'
    )(
        section('分析解答')(
            p`x=-130=-10000010B=-1.000001B×27，阶码 e=127+7=128+6=10000110，所以，用 IEEE 754 单精度浮点数表示为：11000011000000100000000000000000=C3020000H。`,
            p`y=7.25=111.01B=+1.1101B×22，阶码 e=127+2=128+1=10000001，所以，用 IEEE 754 单精度浮点数表示为：01000000111010000000000000000000=40E80000H。`,
            p`i=130=10000010B，用 16 位补码表示为 0082H。`,
            p`上述三个数据在大端机器和小端机器上的存放位置见表 2.13。`,
            img(pic2_6_16)('表 2.13　数据在大端和小端机器中的存放位置')
        )
    ),
    section(
        '33.假定某计算机存储器按字节编址，CPU 从存储器中读出一个 4 字节信息 D=32343538H，该信息的内存地址为 0000 F00CH，按小端方式存放，请回答下列问题。'
    )(
        p`（1）该信息 D 占用了几个内存单元？这几个内存单元的地址及其内容各是什么？`,
        p`（2）若 D 是一个 32 位无符号数，则其值是多少？`,
        p`（3）若 D 是一个 32 位补码表示的带符号整数，则其值是多少？`,
        p`（4）若 D 是一个 IEEE 754 单精度浮点数，则其值是多少？`,
        p`（5）若 D 是一个用 8421 码表示的无符号整数，则其值是多少？`,
        p`（6）若 D 是一个字符串，每个字节的低 7 位表示对应字符的 ASCII 码，则对应字符串是什么？`,
        p`（7）若 D 是两个汉字的国标码，则这两个汉字在 GB 2312—1980 字符集码表中分别位于哪一行和哪一列？`,
        p`（8）若 D 中前 3 个字节分别是一个像素的 R、G、B 分量的颜色值，则其值各是多少？`,
        section('分析解答')(
            p`将 32343538H 展开为二进制表示为 00110010001101000011010100111000B。`,
            p`（1）因为存储器按字节编址，所以 4 个字节占用 4 个内存单元，其地址分别是 0000 F00CH、0000 F00DH、0000 F00EH、0000 F00FH。由于采用小端方式存放，所以，最低有效字节 38H 存放在 0000 F00CH 中，35H 存放在 0000 F00DH 中，34H 存放在 0000 F00EH 中，32H 存放在 0000 F00FH。`,
            p`（2）无符号数。值为 229+228+225+221+220+218+213+212+210+28+25+24+23。`,
            p`（3）补码整数。符号为 0，表示其为正数，其值与无符号数的值一样。`,
            p`（4）IEEE 754 单精度浮点数。根据 IEEE 754 单精度浮点数格式可知，符号位 s=0，为正数；阶码 e=01100100B=100，故阶为 100-127=-27；尾数小数部分 f=0.01101000011010100111000，所以，其值为 1.01101000011010100111B×2-27。`,
            p`（5）8421 码整数。32343538H 各位表示对应十进制数 32343538，所以，其值为 32343538。`,
            p`（6）ASCII 码字符串。各字节的低 7 位分别为 0110010、0110100、0110101、0111000，所以，对应的字符串为「2458」。`,
            p`（7）汉字。对国标码每个字节各自减 20H，得到两个汉字的区位码，分别为 1214H 和 1518H，也即，第一个汉字在 GB 2312—1980 字符集码表中位于第 18（12H）行、第 20（14H）列，第二个汉字位于第 21（15H）行、第 24（18H）列。`,
            p`（8）颜色值。该像素的 R、G、B 分量的颜色值分别为 00110010B=50，00110100B=52，00110101B=53。`
        )
    ),
    section('34.已知下列字符编码：A=1000001，a=1100001，0=0110000，求 D、d、6 的 7 位 ACSII 码和第一位前加入奇校验位后的 8 位编码。')(
        section('分析解答')(
            p`D 的 ASCII 码为：1000001+011=1000100，前面加奇校验位后的编码是 11000100。`,
            p`d 的 ASCII 码为：1100001+011=1100100，前面加奇校验位后的编码是 01100100。`,
            p`6 的 ASCII 码为：0110000+110=0110110，前面加奇校验位后的编码是 10110110。`
        )
    ),
    section('35.在 32 位计算机中运行一个 C 语言程序，在该程序中出现了以下变量的初值，请写出它们对应的机器数（用十六进制表示）。')(
        p`（1）int x=-32768`,
        p`（2）short y=522`,
        p`（3）unsigned z=65530`,
        p`（4）char c='@'`,
        p`（5）float a=-1.1`,
        p`（6）double b=10.5`,
        section('分析解答')(
            p`（1）-215=-1000000000000000B，故机器数为 1…11000000000000000=FFFF8000H。`,
            p`（2）522=1000001010B，故机器数为 0000001000001010=020AH。`,
            p`（3）65530=216-1-5=1111111111111010B，故机器数为 0000FFFAH。`,
            p`（4）『@』的 ASCII 码是 40H。`,
            p`（5）-1.1=-1.00011[0011]…B=-1.000110011001100110011001100…B，阶码为 127+0=01111111，舍入的三位为 110，因此舍入后尾数末位加 1，故机器数为 10111111100011001100110011001101=BF8CCCCDH。`,
            p`（6）10.5=1010.1B=1.0101B×23，阶码为 1023+3=10000000010，故机器数为 0100000000100101[0000]=4025000000000000H。`
        )
    ),
    section(
        '36.在 32 位计算机中运行一个 C 语言程序，在该程序中出现了一些变量，已知这些变量在某一时刻的机器数（用十六进制表示）如下，请写出它们对应的真值。'
    )(
        p`（1）int x：FFFF0006H`,
        p`（2）short y：DFFCH`,
        p`（3）unsigned z：FFFFFFFAH`,
        p`（4）char c：2AH`,
        p`（5）float a：C4480000H`,
        p`（6）double b：C024800000000000H`,
        section('分析解答')(
            p`（1）FFFF0006H=1…10000000000000110B，故 x=-1111111111111010B=-（65535-5）=-65530。`,
            p`（2）DFFCH=1101111111111100B=-010000000000100B，故 y=-（8192+4）=-8196。`,
            p`（3）FFFFFFFAH=1…11010B，故 z=232-6。`,
            p`（4）2AH=00101010B，故 c=42，若 c 表示字符，则 c 为字符『*』。`,
            p`（5）C4480000H=11000100010010000…0B，阶码为 10001000，阶为 136-127=9，尾数为-1.1001B，故 a=-1.1001B×29=-1100100000B=-800。`,
            p`（6）C024800000000000H=1100000000100100100000…0B，阶码为 10000000010，阶为 1026-1023=3，尾数为 1.01001B，故 b=-1.01001B×23=-1010.01B=-10.25。`
        )
    ),
    section('37.以下给出的是一些字符串变量在内存中存放的字符串机器码，请根据 ASCII 码定义写出对应的字符串。指出代码 0AH 和 00H 对应的字符的含义。')(
        p`（1）char*mystring1：68H 65H 6CH 6CH 6FH 2CH 77H 6FH 72H 6CH 64H 0AH 00H`,
        p`（2）char*mystring2：77H 65H 20H 61H 72H 65H 20H 68H 61H 70H 70H 79H 21H 00H`,
        section('分析解答')(
            p`字符串由字符组成，每个字符在内存中存放的是对应的 ASCII 码，因而可根据 ASCII 码和字符之间的对应关系写出字符串。`,
            p`（1）mystring1 指向的字符串为：hello，world\n`,
            p`（2）mystring2 指向的字符串为：we are happy！`,
            p`其中，ASCII 码 00001010B=0AH 对应的是「换行」字符『\n』（LF）。每个字符串在内存存放时最后都会有一个「空」字符『\0』（NUL），其 ASCII 码为 00H。`
        )
    ),
    section('38.以下给出的是一些字符串变量的初值，请写出对应的机器码。')(
        p`（1）char*mystring1="./myfile"`,
        p`（2）char*mystring2="OK，good！"`,
        section('分析解答')(
            p`（1）mysring1 指向的存储区存放内容为：2EH 2FH 6DH 79H 66H 69H 6CH 65H 00H。`,
            p`（2）mysring2 指向的存储区存放内容为：4FH 4BH 2CH 67H 6FH 6FH 64H 21H 00H。`
        )
    ),
    section(
        '39.已知 C 语言中的按位异或运算（“XOR”）用符号「^」表示。对于任意一个位序列 a，存在 a^a=0。C 语言程序可以利用这个特性来实现两个数值交换的功能。以下是一个实现该功能的 C 语言函数：'
    )(
        precode(`                1　void xor_swap（int *x, int *y）
                2　{
                3　    *y=*x ^ *y；               /* 第一步 */
                4　    *x=*x ^ *y；               /* 第二步 */
                5　    *y=*x ^ *y；               /* 第三步 */
                6　}`)(),
        p`假定执行该函数时*x 和*y 的初始值分别为 a 和 b，即*x=a 且*y=b，请说明每一步执行结束后 x 和 y 各自指向的内存单元中的内容分别是什么？`,
        section('分析解答')(
            p`第一步结束后，x 和 y 指向的内存单元内容各为 a 和 a^b。`,
            p`第二步结束后，x 和 y 指向的内存单元内容各为 b 和 a^b。`,
            p`第三步结束后，x 和 y 指向的内存单元内容各为 b 和 a。`
        )
    ),
    section('40.假定某个实现数组元素倒置的函数 reverse_array 调用了第 39 题中给出的 xor_swap 函数：')(
        precode(`                1　void reverse_array(int a[], int len)
                2　{
                3　    int left, right=len-1;
                4　    for (left=0; left<=right; left++, right--)
                5　        xor_swap(&a[left], &a[right]);
                6　}`)(),
        p`当 len 为偶数时，reverse_array 函数的执行没有问题。但是，当 len 为奇数时，函数的执行结果不正确。请问，当 len 为奇数时会出现什么问题？最后一次循环中的 left 和 right 各取什么值？最后一次循环中调用 xor_swap 函数后的返回值是什么？对 reverse_array 函数做怎样的改动就可消除该问题？`,
        section('分析解答')(
            p`当 len 为奇数时，最后一次循环执行的是将最中间的数与自己进行交换，即 left 和 right 都指向最中间数组元素，因而在调用 xor_swap 函数过程中的每一步执行*x^*y 时结果都是 0，并将 0 写入最中间的数组元素，从而改变了原来的数值。`,
            p`可以将 for 循环中的终止条件改为「left<right」，这样，当 len 为奇数时，最中间的数组元素不动。`
        )
    ),
    section(
        '41.假设表 2.14 中的 x 和 y 是某 C 语言程序中的 char 型变量，请根据 C 语言中的按位运算和逻辑运算的定义，填写表 2.14，要求用十六进制形式填写。'
    )(
        img(pic2_6_17)('表 2.14　题 41 用表'),
        section('分析解答')(
            p`根据 C 语言中的按位运算和逻辑运算的定义填写表 2.14，结果见表 2.15。`,
            img(pic2_6_18)('表 2.15　表 2.14 填入结果后的样式')
        )
    ),
    section('42.对于一个 n（n≥8）位的变量 x，请根据 C 语言中按位运算的定义，写出满足下列要求的 C 语言表达式。')(
        p`（1）x 的最高有效字节不变，其余各位全变为 0。`,
        p`（2）x 的最低有效字节不变，其余各位全变为 0。`,
        p`（3）x 的最低有效字节全变为 0，其余各位取反。`,
        p`（4）x 的最低有效字节全变 1，其余各位不变。`,
        section('分析解答')(p`（1）（x>>（n-8））<<（n-8）`, p`（2）x & 0xFF`, p`（3）（（x^~0xFF）>>8）<<8`, p`（3）x|0xFF`)
    ),
    section(
        '43.以下是一个由反汇编器生成的一段针对某个小端方式处理器的机器级代码表示文本，其中，最左边是指令所在的存储单元地址，冒号后面是指令的机器码，最右边是指令的汇编语言表示，即汇编指令。已知反汇编输出中的机器数都采用补码表示，请给出指令代码中画线部分表示的机器数对应的真值。'
    )(
        precode(`80483d2: 81 ec b8 01 00 00      sub   &0x1b8, %esp
80483d8: 8b 55 08               mov   0x8(%ebp), %edx
80483db: 83 c2 14               add   $0x14, %edx
80483de: 8b 85 58 fe ff ff      mov   0xfffffe58(%ebp), %eax
80483e4: 03 02                  add   (%edx), %eax
80483e6: 89 85 74 fe ff ff      mov   %eax, 0xfffffe74(%ebp)
80483ec: 8b 55 08               mov   0x8(%ebp), %edx
80483ef: 83 c2 44               add   $0x44, %edx
80483f2: 8b 85 c8 fe ff ff      mov   0xfffffec8(%ebp), %eax
80483f8: 89 02                  mov   %eax, (%edx)
80483fa: 8b 45 10               mov   0x10(%ebp), %eax
80483fd: 03 45 0c               add   0xc(%ebp), %eax
8048400: 89 85 ec fe ff ff      mov   %eax, 0xfffffeec(%ebp)
8048406: 8b 45 08               mov   0x8(%ebp), %eax
8048409: 83 c0 20               add   $0x20, %eax`)(),
        section('分析解答')(
            p`b8 01 00 00：机器数为 000001B8H，真值为 +110111000B=440。`,
            p`14：机器数为 14H，真值为 +10100B=20。`,
            p`58 fe ff ff：机器数为 FFFFFE58H，真值为-110101000B=-424。`,
            p`74 fe ff ff：机器数为 FFFFFE74H，真值为-110001100B=-396。`,
            p`44：机器数为 44H，真值为 +1000100B=68。`,
            p`c8 fe ff ff：机器数为 FFFFFEC8H，真值为-110001100B=-312。`,
            p`10：机器数为 10H，真值为 +10000B=16。`,
            p`0c：机器数为 0CH，真值为 +1100B=12。`,
            p`ec fe ff ff：机器数为 FFFFFEECH，真值为-100010100B=-276。`,
            p`20：机器数为 20H，真值为 +00100000B=32。`
        )
    ),
    section('44.假设以下 C 语言函数 compare_str_len 用来判断两个字符串的长度，当字符串 str1 的长度大于 str2 的长度时函数返回值为 1，否则为 0。')(
        precode(`                1　int compare_str_len(char *str1, char *str2)
                2　{
                3　    return strlen(str1) - strlen(str2) > 0;
                4　}`)(),
        p`已知 C 语言标准库函数 strlen 原型声明为「size_t strlen（const char*s）；」，其中，size_t 被定义为 unsigned int 类型。请问：函数 compare_str_len（）在什么情况下返回的结果不正确？为什么？为使函数正确返回结果应如何修改代码？`,
        section('分析解答')(
            p`因为 size_t 被定义为 unsigned int 类型，所以，库函数 strlen 的返回值为无符号整数。函数 compare_str_len 中的返回值是 strlen（str1）-strlen（str2）>0，这个关系表达式中「>」号左边是两个无符号数相减，其差还是无符号整数，因而总是大于等于 0，也即在 str1 的长度小于 str2 的长度时结果也为 1。显然，这是错误的。`,
            p`只要将第 3 行语句改为以下形式即可：`,
            precode(`3　    return strlen(str1) > strlen(str2) ;`)()
        )
    ),
    section(
        '45.对于主教材中图 2.6，假设 n=8，机器数 X 和 Y 的真值分别是 x 和 y。请按照主教材图 2.6 的功能填写表 2.16，并给出对每个结果的解释。要求机器数用十六进制形式填写，真值用十进制形式填写。'
    )(
        img(pic2_6_19)('表 2.16　题 45 用表'),
        section('分析解答')(
            p`根据主教材图 2.6 的功能填写表 2.16，得到的结果见表 2.17。`,
            img(pic2_6_20)('表 2.17　表 2.16 填入结果后的样式'),
            p`无符号整数的加减运算的结果是否溢出，通过进位/借位标志 CF 来判断，而带符号整数的加减运算结果是否溢出，通过溢出标志 OF 来判断。对表中每个结果的解释和验证如下：`,
            p`（1）无符号整数 176+140=316，无法用 8 位表示，即结果应有进位，CF 应为 1。验证正确。`,
            p`（2）无符号整数 176-140=36，可用 8 位表示，即结果没有借位，CF 应为 0。验证正确。`,
            p`（3）带符号整数-80+（-116）=-316，无法用 8 位表示，即结果溢出，OF 应为 1。验证正确。`,
            p`（4）带符号整数-80-（-116）=36，可用 8 位表示，即结果不溢出，OF 应为 0。验证正确。`,
            p`（5）无符号整数 126+93=219，可用 8 位表示，即结果没有进位，CF 应为 0。验证正确。`,
            p`（6）无符号整数 126-93=33，可用 8 位表示，即结果没有借位，CF 应为 0。验证正确。`,
            p`（7）带符号整数 126+93=219，无法用 8 位表示，即结果溢出，OF 应为 1。验证正确。`,
            p`（8）带符号整数 126-93=33，可用 8 位表示，即结果不溢出，OF 应为 0。验证正确。`
        )
    ),
    section(
        '46.在字长为 32 位的计算机上，一个函数原型声明为「int ch_mul_overflow（int x，int y）；」，该函数用于对两个 int 型变量 x 和 y 的乘积判断是否溢出，若溢出则返回 1，否则返回 0。请使用 64 位精度的整数类型 long long 来编写该函数。'
    )(
        section('分析解答')(
            p`使用 64 位精度的乘法实现两个 32 位带符号整数相乘（专门的补码乘法运算），可以通过乘积的高 32 位和低 32 位的关系来进行溢出判断。判断规则是：若高 32 位乘积中每一位都与低 32 位的最高位相同，也即，若高 33 位为全 1 或全 0，则不溢出；否则溢出。`,
            precode(`1　int ch_mul_overflow(int x, int y)
2　{
3　    long long prod_64= (long long) x*y;
4　    return prod_64 != (int) prod_64;
5　}`)(),
            p`第 3 行赋值语句的右边采用强制类型转换，使得 x 和 y 相乘的结果强制以 64 位乘积的形式保留在 64 位 long long 型变量 prod_64 中。在第 4 行关系运算符！= 右边的强制类型转换，将一个 64 位乘积的高 32 位丢弃，然后，在进行关系运算时，因为关系运算符！= 的左边是一个 64 位整数，所以，右边的 32 位数必须再进行符号扩展以转换为 64 位整数，然后再与左边的整数进行比较。若乘积没有溢出，则丢弃的高 32 位和后面符号扩展的 32 位相同，因而比较结果一定是相等，返回为 0；若乘积有溢出，则比较结果一定不相等，返回为 1。`,
            p`若第 3 行赋值语句改成如下形式，则 prod_64 得到的是低 32 位乘积进行符号扩展后的 64 位值，因此，当结果溢出时，prod_64 中得到的并不是真正的 64 位乘积。`,
            precode(`3　    long long prod_64= x*y;`)()
        )
    ),
    section('47.对于主教材 2.7.5 节中例 2.31 存在的整数溢出漏洞，如果将其中的第 5 行改为以下两个语句：')(
        precode(`                unsigned long long arraysize=count*(unsigned long long)sizeof(int);
                int *myarray = (int *) malloc(arraysize);`)(),
        p`已知 C 语言标准库函数 malloc 的原型声明为「void*malloc（size_t size）；」，其中，size_t 定义为 unsigned int 类型，则上述改动能否消除整数溢出漏洞？若能，则说明理由；若不能，则给出修改方案。`,
        section('分析解答')(
            p`上述改动无法消除整数溢出漏洞，这种改动方式虽然使得 arraysize 的表示范围扩大了，避免了 arraysize 的溢出，不过，当调用 malloc 函数时，若 arraysize 的值大于 32 位的 unsigned int 的最大可表示值，则 malloc 函数还是只能按 32 位数给出的值去申请空间，同样会发生整数溢出漏洞。`,
            p`程序应该在调用 malloc 函数之前检测所申请的空间大小是否大于 32 位无符号整数的可表示范围，若是，则返回-1，表示不成功；否则，再申请空间并继续进行数组复制。修改后的程序如下：`,
            precode(` 1　/* 复制数组到堆中，count 为数组元素个数 */
 2　int copy_array（int *array, int count） {
 3　    int i；
 4　/* 在堆区申请一块内存 */
 5　    unsigned long long arraysize=count*（unsigned long long）sizeof（int）；
 6　    size_t myarraysize=（size_t） arraysize；
 7　    if （myarraysize!=arraysize）
 8　        return -1；
 9　    int *myarray = （int *） malloc（myarraysize）；
10　    if （myarray == NULL）
11　        return -1；
12　    for （i = 0; i < count; i++）
13　        myarray[i] = array[i]；
14　    return count；
15　}`)()
        )
    ),
    section(
        '48.假设一次整数加法、一次整数减法和一次移位操作都只需一个时钟周期，一次整数乘法操作需要 10 个时钟周期。若 x 为一个整型变量，现要计算 55*x，请给出一种计算表达式，使得所用时钟周期数最少。'
    )(
        section('分析解答')(
            p`根据表达式 55*x=（64-8-1）*x=64*x-8*x-x 可知，完成 55*x 只要两次移位操作和两次减法操作，共 4 个时钟周期。若将 55 分解为 32+16+4+2+1，则需要 4 次移位操作和 4 次加法操作，共 8 个时钟周期。`,
            p`上述两种方式都比直接执行一次乘法操作所用的时钟周期数少。`
        )
    ),
    section(
        '49.假设 x 为一个 int 型变量，请给出一个用来计算 x/32 的值的函数 div32。要求不能使用除法、乘法、模运算、比较运算、循环语句和条件语句，可以使用右移、加法以及任何按位运算。'
    )(
        section('分析解答')(
            p`根据主教材 2.7.6 节内容可知，带符号整数 x 除以 2k的值可以用移位方式实现。若 x 为正数，则将 x 右移 k 位得到商；若 x 为负数，则 x 需要加一个偏移量（2k-1）后再右移 k 位得到商。因此，在执行右移操作前必须先计算偏移量，计算公式如下：`,
            img(pic2_6_21)(),
            p`x 的符号位在最左边，因此，表达式 x>>31 的计算结果得到 32 个符号位，x 小于 0 时为 32 个 1，否则为 32 个 0。偏移量 b 可以通过用掩码的方式得到。`,
            p`函数 div32 的 C 语言源代码如下：`,
            precode(`int div32（int x）
{   /* 根据 x 的符号得到偏移量 b */
    int b=（x>>31） & 0x1F；
    return （x+b）>>5；
}`)()
        )
    ),
    section('50.无符号整数变量 ux 和 uy 的声明和初始化如下：')(
        precode(`unsigned ux=x;
unsigned uy=y;`)(),
        p`若 sizeof（int）=4，则对于任意 int 型变量 x 和 y，判断以下关系表达式是否永真。若永真，则给出证明；若不永真，则给出结果为假时 x 和 y 的取值。`,
        p`（1）（x*x）>=0`,
        p`（2）（x-1<0）||x>0`,
        p`（3）x<0||-x<=0`,
        p`（4）x>0||-x>=0`,
        p`（5）x&0xf！=15||（x<<28）<0`,
        p`（6）x>y==（-x<-y）`,
        p`（7）~x+~y==~（x+y）`,
        p`（8）（int）（ux-uy）==-（y-x）`,
        p`（9）（（x>>2）<<2）<=x`,
        p`（10）x*4+y*8==（x<<2）+（y<<3）`,
        p`（11）x/4+y/8==（x>>2）+（y>>3）`,
        p`（12）x*y==ux*uy`,
        p`（13）x+y==ux+uy`,
        p`（14）x*~y+ux*uy==-x`,
        section('分析解答')(
            p`（1）（x*x）>=0 非永真。例如，当 x=65534 时，则 x*x=（216-2）*（216-2）=232-2*2*216+4（mod 232）=-（218-4）=-262140。x 的机器数为 0000FFFEH，x*x 的机器数为 FFFC0004H。`,
            p`（2）（x-1<0）||x>0 非永真。当 x=-2147483648 时，显然，x<0，x 的机器数为 80000000H；x-1 的机器数为 7FFFFFFFH，符号位为 0，因而 x-1>0。此时，（x-1<0）和 x>0 两者都不成立。`,
            p`（3）x<0||-x<=0 永真。若 x>0，x 符号位为 0 且数值部分为非 0（至少有一位是 1），从而使-x 的符号位一定是 1，即则-x<0；若 x=0，则-x=0。综上，只要 x<0 为假，则-x<=0 一定为真，因而是永真。`,
            p`（4）x>0||-x>=0 非永真。当 x=-2147483648 时，x<0，且 x 和-x 的机器数都为 80000000H，即-x<0。此时，x>0 和-x≥0 两者都不成立。`,
            p`（5）x&0xf！=15||（x<<28）<0 非永真。这里！= 的优先级比&（按位与）的优先级高。因此，若 x=0，则 x&0xf！=15 为 0，（x<<28）<0 也为 0，所以结果为假。`,
            p`（6）x>y==（-x<-y）非永真。当 x=-2147483648、y 任意（除-2147483648 外），或者 y=-2147483648、x 任意（除-2147483648 外）时不等。因为 int 型负数-2147483648 是最小负数，该数取负后结果仍为-2147483648，而不是 2147483648。`,
            p`（7）~x+~y==~（x+y）永假。[-x]补=~[x]补+1，[-y]补=~[y]补+1，故 ~[x]补+~[y]补=[-x]补+[-y]补-2。[-（x+y）]补=~[x+y]补+1，故 ~[x+y]补=[-（x+y）]补-1=[-x]补+[-y]补-1。由此可见，左边比右边少 1。`,
            p`（8）（int）（ux-uy）==-（y-x）永真。（int）ux-uy=[x-y]补=[x]补+[-y]补=[-y+x]补=[-（y-x）]补。`,
            p`（9）（（x>>2）<<2）<=x 永真。因为右移总是向负无穷大方向取整。`,
            p`（10）x*4+y*8==（x<<2）+（y<<3）永真。因为带符号整数 x 乘以 2k完全等于 x 左移 k 位，无论结果是否溢出。`,
            p`（11）x/4+y/8==（x>>2）+（y>>3）非永真。当 x=-1 或 y=-1 时，x/4 或 y/8 等于 0，但是，因为-1 的机器数为全 1，所以，x>>2 或 y>>3 还是等于-1。此外，当 x 或 y 为负数且 x 不能被 4 整除或 y 不能被 8 整除，则 x/4 不等于 x>>2，y/8 不等于 y>>3。`,
            p`（12）x*y==ux*uy 永真。根据第 2.7.5 节内容可知，x*y 的低 32 位和 ux*uy 的低 32 位是完全一样的位序列。`,
            p`（13）x+y==ux+uy 永真。根据第 2.7.4 节内容可知，带符号整数和无符号整数都是在同一个整数加减运算部件中进行运算的，x 和 ux 具有相同的机器数，y 和 uy 具有相同的机器数，因而 x+y 和 ux+uy 具有完全一样的位序列。`,
            p`（14）x*~y+ux*uy==-x 永真。-y=~y+1，即 ~y=-y-1。而 ux*uy=x*y，因此，等式左边为 x*（-y-1）+x*y=-x。`
        )
    ),
    section('51.变量 dx、dy 和 dz 的声明和初始化如下：')(
        precode(`double dx = (double) x;
double dy = (double) y;
double dz = (double) z;`)(),
        p`若 float 和 double 分别采用 IEEE 754 单精度和双精度浮点数格式，sizeof（int）=4，则对于任意 int 型变量 x、y 和 z，判断以下关系表达式是否永真。若永真，则给出证明；若不永真，则给出结果为假时 x 和 y 的取值。`,
        p`（1）dx*dx>=0`,
        p`（2）（double）（float）x==dx`,
        p`（3）dx+dy==（double）（x+y）`,
        p`（4）（dx+dy）+dz==dx+（dy+dz）`,
        p`（5）dx*dy*dz==dz*dy*dx`,
        p`（6）dx/dx==dy/dy`,
        section('分析解答')(
            p`（1）dx*dx>=0 永真。double 型数据用 IEEE 754 标准表示，尾数用原码小数表示，符号和数值部分分开运算。不管结果是否溢出，都不会影响乘积的符号。`,
            p`（2）（double）（float）x==dx 非永真。当 int 型变量 x 的有效位数比 float 型可表示的最大有效位数 24 更多时，x 强制转换为 float 型数据时有效位数丢失，而将 x 转换为 double 型数据时没有有效位数丢失。也即等式左边可能是近似值，而右边是精确值。`,
            p`（3）dx+dy==（double）（x+y）非永真。因为 x+y 可能会溢出，而 dx+dy 不会溢出。`,
            p`（4）（dx+dy）+dz==dx+（dy+dz）永真。因为 dx、dy 和 dz 是由 32 位 int 型数据转换得到的，而 double 类型可以精确表示 int 类型数据，并且对阶时尾数移位位数不会超过 52 位，因此尾数不会舍入，因而不会发生大数吃小数的情况。`,
            p`但是，如果 dx、dy 和 dz 是任意 double 类型数据，则非永真。`,
            p`（5）dx*dy*dz==dz*dy*dx 非永真。相乘的结果可能产生舍入。`,
            p`（6）dx/dx==dy/dy 非永真。dx 和 dy 中只要有一个为 0、另一个不为 0 就不相等。`
        )
    ),
    section(
        '52.假设浮点数的阶码和尾数均采用补码表示，且位数分别为 5 位和 7 位（均含 2 位符号位，即变形补码）。若有两个数 x=27×15/16，y=25×3/8，请用浮点加法计算 x+y 的最终结果。'
    )(
        section('分析解答')(
            p`先将两个数的尾数部分变成分母为 32 的形式，即 x=27×30/32，y=25×12/32，x 和 y 转换成题设的浮点数格式，x：00.11110，00111；y：00.01100，00101，然后进行浮点数加/减运算。y 对阶后为：00.00011，00111，因此尾数相加结果为 00.11110+00.00011=01.00001，该尾数形式需要右规，即尾数右移一位，若采用「0 舍 1 入」舍入法，右规后尾数为 00.10001，阶码加 1 后为 01000，因此，右规后为 00.10001，01000，最后要对该结果进行溢出判断。显然，阶码的两个符号位不同，故结果溢出。`
        )
    ),
    section(
        '53.假设有两个实数 x 和 y，x=-68，y=-8.25，它们在 C 语言程序中定义为 float 型变量（用 IEEE 754 单精度浮点数格式表示），x 和 y 分别存放在寄存器 A 和 B 中。另外，还有两个寄存器 C 和 D。A、B、C、D 都是 32 位寄存器。请回答下列问题（要求最终用十六进制表示）。'
    )(
        p`（1）寄存器 A 和 B 中的内容分别是什么？`,
        p`（2）若 x 和 y 相加后的结果存放在寄存器 C 中，则寄存器 C 中的内容是什么？`,
        p`（3）若 x 和 y 相减后的结果存放在寄存器 D 中，则寄存器 D 中的内容是什么？`,
        section('分析解答')(
            p`（1）x=-68=-1000100 B=-1.0001B×26，因此，符号位为 1，阶码为 10000101B，尾数小数部分为 00010000000000000000000B，浮点数表示形式为 11000010100010000000000000000000，十六进制形式为 C2880000H。y=-8.25=-1000.01B=-1.00001B×23，因此，符号位为 1，阶码为 10000010B，尾数小数部分为 00001000000000000000000B，浮点数表示形式为 11000001000001000000000000000000，十六进制形式为 C1040000H。因此，寄存器 A 和 B 中的内容分别是 C2880000H、C1040000H。`,
            p`（2）两个浮点数相加的步骤如下。`,
            p`① 对阶。`,
            p`[Ex]移=10000101，[Ey]移=10000010，[ΔE]补=[Ex-Ey]补=[Ex]移+[-[Ey]移]补=10000101+01111110=00000011，Ex-Ey=+3，Ex 大于 Ey，所以对 y 进行对阶。对阶后，y=-0.00100001×26，即 y 的浮点表示为 110000101（0）00100001000000000000000。`,
            p`② 尾数相加。`,
            p`x 的尾数为-1.00010000000000000000000，y 的尾数为-0.00100001000000000000000。原码加法运算规则为「同号求和，异号求差」。因两数符号相同，故做加法，结果为-1.00110001000000000000000。因此，x+y 的结果为-1.00110001×26，符号位为 1，尾数为 00110001000000000000000，阶码为 127+6=128+5=10000101B，浮点数表示为 11000010100110001000000000000000，转换为十六进制形式为 C2988000H。因此，寄存器 C 中的内容是 C2988000H。`,
            p`（3）两个浮点数相减的步骤同加法，对阶的结果也一样，只是尾数相减。原码减法运算规则为「同号求差，异号求和」。因两数符号相同，故做减法。数值部分由被减数加上减数的补码（各位取反，末位加 1）得到，即：`,
            img(pic2_6_22)(),
            p`最高数值位产生进位，表明所得数值位正确，且结果的符号取被减数的符号，即结果为负数。因此，x 减 y 的结果为-0.11101111×26=-1.1101111×25。也即符号位为 1，尾数为 11011110000000000000000，阶码为 127+5=128+4=10000100B，浮点数表示为 11000010011011110000000000000000，转换为十六进制形式为 C26F 0000H。因此，寄存器 D 中的内容是 C26F 0000H。`
        )
    ),
    section('54.在 IEEE 754 浮点数运算中，当结果的尾数出现什么形式时需要进行左规？什么形式时需要进行右规？如何进行左规？如何进行右规？')(
        section('分析解答')(
            p`（1）对于结果为 ±1x.xx…x 的情况，需要进行右规，即尾数右移一位，阶码加 1。右规操作可以表示为：Mb←Mb×2-1，Eb←Eb+1。右规时注意以下两点：① 尾数右移时，最高位「1」被移到小数点前一位作为隐藏位，最后一位移出时，要考虑舍入。② 阶码加 1 时，直接在末位加 1。`,
            p`（2）对于结果为 ±0.00…01x…x 的情况，需要进行左规，即数值位逐次左移，阶码逐次减 1，直到将第一位「1」移到小数点左边。假定 k 为结果中「±」和左边第一个 1 之间连续 0 的个数，则左规操作可以表示为：Mb←Mb×2k，Eb←Eb-k。左规时注意以下两点：① 尾数左移时数值部分最左 k 个 0 被移出，因此，相对来说，小数点右移了 k 位。因为进行尾数相加时，默认小数点位置在第一个数值位（即隐藏位）之后，所以小数点右移 k 位后被移到了第一位 1 后面，这个 1 就是隐藏位。② 执行 Eb←Eb-k 时，每次都在末位减 1，一共减 k 次。`
        )
    ),
    section('55.在 IEEE 754 浮点数运算中，如何判断浮点运算的结果是否溢出？')(
        section('分析解答')(
            p`浮点运算结果是否溢出，并不以尾数溢出来判断，而主要看阶码是否溢出。尾数溢出时，可通过右规操作进行纠正。因为在进行规格化、尾数舍入和浮点数的乘/除运算过程中，都需要对阶码进行加、减运算，所以在这些操作过程中，可能会发生阶码上溢或阶码下溢。阶码上溢时，说明结果的数值太大，无法表示，是真正的溢出；阶码下溢时，说明结果数值太小，可以把结果近似为 0。`
        )
    ),
    section(
        '56.假设浮点数格式为：阶码是 4 位移码，偏置常数为 8，尾数是 6 位补码（采用双符号位），用浮点运算规则分别计算在不采用任何附加位和采用 2 位附加位（保护位、舍入位）的情况下以下各式的值（假定对阶和右规时采用就近舍入到偶数方式）。'
    )(
        p`（1）（15/16）×27+（2/16）×25`,
        p`（2）（15/16）×27-（2/16）×25`,
        p`（3）（15/16）×25+（2/16）×27`,
        p`（4）（15/16）×25-（2/16）×27`,
        section('分析解答')(
            p`将上述各式中的数据用相应的变量 A、B、C、D 代替。`,
            p`A=（15/16）×27=0.1111B×27，[A]浮=00.1111，1111。`,
            p`B=（2/16）×25=0.0010B×25=0.1000B×23，[B]浮=00.1000，1011。`,
            p`C=（15/16）×25=0.1111B×25，[C]浮=00.1111，1101。`,
            p`D=（2/16）×27=0.0010B×27=0.1000B×25，[D]浮=00.1000，1101。`,
            p`不采用任何附加位时的计算结果如下。`,
            p`（1）计算 A+B：[ΔE]补=[EA]移+[-[EB]移]补=1111+0101=0100（mod 24），因此 ΔE=4，故需对 B 进行对阶，因为采用就近舍入到偶数方式，所以，B 的尾数右移 4 位后直接舍去 1000，又因为「1000」是中间值，因此尾数取偶数 00.0000，故对阶后结果为[B]浮=00.0000，1111。由于 B 的尾数为 0，因此，[A+B]浮=[A]浮=00.1111，1111。故 A+B=A=（15/16）×27。`,
            p`（2）计算 A-B：对阶结果与（1）相同，故[A-B]浮=[A]浮=00.1111，1111。故 A-B=A=（15/16）×27。`,
            p`（3）计算 C+D：[ΔE]补=[EC]移+[-[ED]移]补=1101+0011=0000（mod 24），因此 ΔE=0，故无需对阶。尾数直接加：[MC]补+[MD]补=00.1111+00.1000=01.0111，因为补码的两个符号位不同，所以尾数溢出，需要右规。右规时需对尾数进行舍入，阶码加 1。舍入最后一位的「1」是中间值，因此尾数取偶数 00.1100，阶码 1101 加 1 后为 1110，所以，[C+D]浮=00.1100，1110。故 C+D=（12/16）×26。`,
            p`（4）计算 C-D：对阶结果与（3）相同。尾数直接减：[MC]补+[-MD]补=00.1111+11.1000=00.0111。显然，尾数需左规。左规时，尾数左移一位，阶码减 1。因此，最终尾数为 00.1110，阶码 1101 减 1 后为 1100。因此，[C-D]浮=00.1110，1100，故 C-D=（14/16）×24。`,
            p`采用两位附加位时的计算结果如下。`,
            p`（1）计算 A+B：[ΔE]补=[EA]移+[-[EB]移]补=1111+0101=0100（mod 24），因此 ΔE=4，故需对 B 进行对阶，对阶后结果为[B]浮=00.000010，1111。尾数相加结果为：[MA]补+[MB]补=00.111100+00.000010=00.111110，因此，[A+B]浮=00.111110，1111。最后对尾数附加位 10 进行舍入，因为舍入的是中间值，所以尾数结果强迫为偶数，即尾数末位加 1，得尾数为 01.0000，因此，尾数需右规为 00.1000，同时，阶码 1111 加 1，产生阶码上溢，因而导致结果溢出。因此，A+B 的结果溢出。`,
            p`（2）计算 A-B：对阶结果与（1）相同，尾数相减结果为：[MA]补+[-MB]补=00.111100+11.111110=00.111010，因此，[A-B]浮=00.111010，1111。最后对尾数附加位 10 进行舍入，因为舍入的是中间值，所以尾数结果强迫为偶数，得尾数为 00.1110，因此，[A-B]浮=00.1110，1111。故 A-B=（14/16）×27。`,
            p`（3）计算 C+D：[ΔE]补=[EC]移+[-[ED]移]补=1101+0011=0000（mod 24），因此 ΔE=0，故无需对阶。尾数直接加：[MC]补+[MD]补=00.111100+00.100000=01.011100，因为补码的两个符号位不同，所以尾数溢出，需要右规。右规时需对尾数进行舍入，阶码加 1。舍入的「100」是中间值，因此尾数取偶数 00.1100，阶码 1101 加 1 后为 1110，所以，[C+D]浮=00.1100，1110。故 C+D=（12/16）×26。`,
            p`（4）计算 C-D：对阶结果与（3）相同，尾数直接减：[MC]补+[-MD]补=00.111100+11.100000=00.011100。显然，尾数需左规。左规时，尾数左移一位，阶码减 1。因此，最终尾数为 00.1110，阶码 1101 减 1 后为 1100。因此，[C-D]浮=00.1110，1100，故 C-D=（14/16）×24。`
        )
    ),
    section('57.采用 IEEE 754 单精度浮点数格式计算下列表达式的值。')(
        p`（1）0.75+（-65.25）`,
        p`（2）0.75-（-65.25）`,
        section('分析解答')(
            p`x=0.75=0.11B=（1.10…0）2×2-1，y=-65.25=-1000001.01B=（-1.00000101…0）2×26。用 IEEE 754 标准单精度格式表示为[x]浮=00111111010…0，[y]浮=110000101000001010…0。假定用 Ex、Ey分别表示[x]浮和[y]浮中的阶码，Mx、My分别表示[x]浮和[y]浮中的尾数，即 Ex=01111110，Mx=0（1）.10…0，Ey=10000101，My=1（1）.000001010…0。尾数 Mx和 My的小数点前面有两位，第一位为数符，第二位加了括号，是隐藏位「1」。以下是机器中浮点数加/减运算过程（假定保留两位附加位：保护位和舍入位）。`,
            p`（1）0.75+（-65.25）`,
            p`① 对阶。`,
            p`[ΔE]补=Ex+[-Ey]补=01111110+01111011=11111001（mod 28），ΔE=-7，故需对 x 进行对阶，结果为 Ex=Ey=10000101，Mx=00.000000110…000，即将 x 的尾数 Mx右移 7 位，符号不变，数值高位补 0，隐藏位右移到小数点后面，最后移出的两位保留。`,
            p`② 尾数相加。`,
            p`Mb=Mx+My=00.000000110…000+11.000001010…000（注意小数点在隐藏位后）。根据原码加/减法运算规则（加法运算规则为「同号求和，异号求差」），得：00.000000110…000+11.000001010…000=11.000000100…000。上式尾数中最左边第一位是符号位，其余都是数值部分，尾数后面两位是附加位（加粗）。`,
            p`③ 规格化。`,
            p`根据所得尾数的形式，数值部分最高位为 1，所以不需要进行规格化。`,
            p`④ 舍入。`,
            p`将结果的尾数 Mb中最后两位附加位舍入，从本例来看，不管采用什么舍入法，结果都一样，都是把最后两个 0 去掉，得：Mb=11.000000100…0。`,
            p`⑤ 溢出判断。`,
            p`在上述阶码计算和调整过程中，没有发生「阶码上溢」和「阶码下溢」的问题。`,
            p`最终结果为 Eb=10000101，Mb=1（1）.00000010…0，即：（-1.0000001）2×26=-64.5。`,
            p`（2）0.75-（-65.25）`,
            p`① 对阶。`,
            p`同上述（1）中对阶过程一样。`,
            p`② 尾数相减。`,
            p`Mb=Mx-My=00.000000110...000-11.000001010…000，根据原码加/减法运算规则（减法运算规则为「同号求差，异号求和」），得：00.000000110…000-11.000001010…000=01.00001000…000。上式尾数中最左边第一位是符号位，其余都是数值部分，尾数后面两位是附加位（加粗）。`,
            p`③ 规格化。`,
            p`根据所得尾数的形式，数值部分最高位为 1，不需要进行规格化。`,
            p`④ 舍入。`,
            p`把结果的尾数 Mb中最后两位附加位舍入掉，得：Mb=01.00001000…0。`,
            p`⑤ 溢出判断。`,
            p`在上述阶码计算和调整过程中，没有发生「阶码上溢」和「阶码下溢」的问题。`,
            p`最后结果为 Eb=10000101，Mb=0（1）.00001000…0，即：（+1.00001）2×26=+66。`
        )
    ),
    section(
        '58.以下是函数 fpower2 的 C 语言源程序，它用于计算 2x 的浮点数表示，其中调用了函数 u2f，u2f 用于将一个无符号整数表示的 0/1 序列作为 float 类型返回。请填写 fpower2 函数中的空白部分，以使其能正确计算结果。'
    )(
        precode(` 1　float fpower2（int x）
 2　{
 3　    unsigned exp， frac， u；
 4
 5　    if （x<________） {            /* 值太小，返回 0.0 */
 6　        exp = ________；
 7　        frac = ________；
 8　    } else if （x<________） {     /* 返回非规格化结果 */
 9　        exp = ________；
10　        frac = ________；
11　    } else if （x<________） {     /* 返回规格化结果 */
12　        exp =________；
13　        frac =________；
14　    } else {                        /* 值太大，返回 +∞ */
15　        exp = ________；
16　        frac = ________；
17　    }
18　    u = exp << 23 | frac；
19　    return u2f（u）；
20　}`)(),
        section('分析解答')(
            precode(` 1　float fpower2(int x)
 2　{
 3　    unsigned exp, frac, u;
 4
 5　    if (x<  -149  ) {             /* 值太小，返回 0.0 */
 6　        exp =      0     ;
 7　        frac =     0     ;
 8　    } else if (x<  -126  ) {          /* 返回非规格化结果 */
 9　        exp =      0     ;
10　        frac =    0x400000>>(-x-127)   ;
11　    } else if (x<  128   ) {          /* 返回规格化结果 */
12　        exp =    x+127   ;
13　        frac =     0     ；
14　    } else {                    /* 值太大，返回 +∞ */
15　        exp =      255   ;
16　        frac =     0     ;
17　    }
18　    u = exp << 23 | frac;
19　    return u2f(u);
20　}`)()
        )
    ),
    section(
        '59.以下是一组关于浮点数按位级进行运算的编程题目，其中用到一个数据类型 float_bits，它被定义为 unsigned int 类型。以下程序代码必须采用 IEEE 754 标准规定的运算规则，例如，舍入应采用就近舍入到偶数的方式。此外，代码中不能使用任何浮点数类型、浮点数运算和浮点常数，只能使用 float_bits 类型；不能使用任何复合数据类型，如数组、结构和联合等；可以使用无符号整数或带符号整数的数据类型、常数和运算。要求编程实现以下功能并进行正确性测试，需要针对参数 f 的所有 32 位组合情况进行处理。'
    )(
        p`（1）计算浮点数 f 的绝对值 |f|。若 f 为 NaN，则返回 f；否则返回 |f|。函数原型为：`,
        p`float_bits float_abs（float_bits f）；`,
        p`（2）计算浮点数 f 的负数-f。若 f 为 NaN，则返回 f；否则返回-f。函数原型为：`,
        p`float_bits float_neg（float_bits f）；`,
        p`（3）计算 0.5*f。若 f 为 NaN，则返回 f；否则返回 0.5*f。函数原型为：`,
        p`float_bits float_half（float_bits f）；`,
        p`（4）计算 2.0*f。若 f 为 NaN，则返回 f；否则返回 2.0*f。函数原型为：`,
        p`float_bits float_twice（float_bits f）；`,
        p`（5）将 int 型整数 i 的位序列转换为 float 型位序列。函数原型为：`,
        p`float_bits float_i2f（int i）；`,
        p`（6）将浮点数 f 的位序列转换为 int 型位序列。若 f 为非规格化数，则返回值为 0；若 f 是 NaN 或 ±∞ 或超出 int 型数可表示范围，则返回值为 0x80000000；若 f 带小数部分，则考虑舍入。函数原型为：`,
        p`int float_f2i（float_bits f）；`,
        section('分析解答')(
            p`（1）计算浮点数 f 的绝对值 |f|。若 f 为 NaN，则返回 f；否则返回 |f|。`,
            precode(`float_bits float_abs（float_bits f） {
    unsigned sign=f>>31；
    unsigned exp=f>>23&0xFF；
    unsigned frac=f&0x7FFFFF；
    if （exp==0xFF）&&（frac!=0） || （sign==0）     /* f 为 NaN 或正数*/
        return f；
    else                              /* f 为负数*/
        return f & 0x7FFFFFFF；
}`)(),
            p`（2）计算浮点数 f 的负数-f。若 f 为 NaN，则返回 f；否则返回-f。`,
            precode(`float_bits float_neg（float_bits f） {
    unsigned exp=f>>23&0xFF；
    unsigned frac=f&0x7FFFFF；
    if （exp==0xFF）&&（frac!=0）               /* f 为 NaN */
        return f；
    else
        return f ^ 0x80000000；
}`)(),
            p`（3）计算 0.5*f。若 f 为 NaN，则返回 f；否则返回 0.5*f。`,
            precode(`float_bits float_half（float_bits f） {
    unsigned sign=f>>31；
    unsigned exp=f>>23&0xFF；
    unsigned frac=f&0x7FFFFF；
    if （exp==0xFF）&&（frac!=0）               /* f 为 NaN */
        return f；
    else if （(exp==0)||(exp==0xFF)） && （frac==0）  /* f 为 0 或 ∞*/
        return f；
    else if （exp==0） && （frac!=0）          /* f 为非规格化数 */
        return sign<<31 | frac>>1；
    else {                              /* f 为规格化数 */
            exp=exp+0xFF；
            if （exp!=0）                    /* 0.5*f 为规格化数*/
                return  sign<<31 | exp << 23 | frac；
            else                      /* 0.5*f 为非规格化数*/
                return sign<<31 | （frac | 0x800000）>>1；
    }
}`)(),
            p`（4）计算 2.0*f。若 f 为 NaN，则返回 f；否则返回 2.0*f。`,
            precode(`float_bits float_twice（float_bits f） {
    unsigned sign=f>>31；
    unsigned exp=f>>23&0xFF；
    unsigned frac=f&0x7FFFFF；
    if （exp==0xFF）&&（frac!=0）                 /* f 为 NaN */
        return f；
    else if （(exp==0)||(exp==0xFF)） && （frac==0）  /* f 为 0 或 ∞*/
        return f；
    else if （exp==0） && （frac!=0）  {            /* f 为非规格化数 */
            if （frac&0x400000）            /* f 的尾数第一位为 1 */
                return sign<<31 | 1<<23 | （frac&0x3FFFFF）<<1；
            else                      /* f 的尾数第一位为 0 */
                return sign<<31 | frac<<1；
        }
    else {                           /* f 为规格化数 */
        exp=exp+0x01；
        if （exp!=0xFF）                      /* 2.0*f 为规格化数 */
            return  sign<<31 | exp << 23 | frac；
        else                           /* 2.0*f 发生阶码溢出*/
            return sign<<31 | exp<<23 ；
    }
}`)(),
            p`（5）将 int 型整数 i 的位序列转换为 float 型位序列。`,
            precode(`float_bits float_i2f（int i） {
    unsigned pre_count=30；
    unsigned pos_count=31；
    unsigned sign=（unsigned） i >>31；
    unsigned neg_i；
    if （i==0）                           /* i 为 0 */
        return i；
    if （sign==0）  {                      /* i 为正数 */
        while （i>>pre_count==0）  pre_count--；
        return sign<<31 | （127+pre_count） << 23 | （unsigned） （i<< (32-pre_count)）>>23；
    }
    else  {                           /* i 为负数 */
        while （i<<pos_count==0）  pos_count--；
        neg_i=（~(i>>(32-pos_count)) << (32-pos_count)） | （1<< (31-pos_count)）；
        while （neg_i>>pre_count==0）  pre_count--；
        return sign<<31 | （127+pre_count） << 23 | neg_i<< （32-pre_count） >>23；
    }
}`)(),
            p`（6）将浮点数 f 的位序列转换为 int 型位序列。若 f 为非规格化数，则返回值为 0；若 f 是 NaN 或 ±∞ 或超出 int 型数范围，则返回值为 0x80000000；若 f 带小数部分，则考虑舍入。`,
            precode(`int float_f2i（float_bits f）  {
    unsigned sign=f>>31；
    unsigned exp=f>>23&0xFF；
    unsigned frac=f&0x7FFFFF；
    unsigned exp_value = exp -127；
    unsigned neg_i；
    unsigned pos_count=31；
    if （(exp==0xFF) || (exp_value>30)）       /* f 为 NaN 或 ∞ 或值太大 */
        return 0x80000000；
    else if （(exp==0) || (exp_value <0)）       /* f 为非规格化数或 0 或值太小 */
        return 0；
    else if （sign==0）                       /* f 为正的规格化数 */
        return  （1<<30 | frac<<7） >> （30-exp_value）；
    else {                            /* f 为负的规格化数 */
        neg_i = （1<<30 | frac<<7） >> （30-exp_value）；
        while （neg_i<<pos_count==0）  pos_count--；
        return （~(neg_i>>(32-pos_count)) << (32-pos_count)） | （1<< (31-pos_count)）；
    }
}`)()
        )
    )
).elem
