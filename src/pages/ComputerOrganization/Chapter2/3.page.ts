import { p, section } from '@src/components/@write'
const title = '2.3　基本术语解释'
const page = section(title)(
    section('机器数（computer word）')(p`通常将数值数据在计算机内部编码表示的数称为机器数。机器数中只有 0 和 1 两种符号。`),
    section('真值（natural number）')(p`机器数真正的值（即原来带有正负号的数）称为机器数的真值。`),
    section('数值数据（numerical data）')(
        p`数值数据是指有确定的值的数据，在数轴上能找到其对应的点，可以比较其大小。确定一个数值数据的值有三个要素：进位记数制、定／浮点表示和数的编码表示。也就是说，给定一个数字序列，如果不说明这个数字序列是几进制数、小数点的位置在哪里、采用什么编码方式，那么这个数字序列的值是无法确定的。`
    ),
    section('非数值数据（non-numerical data）')(p`非数值数据是指在数轴上没有确定的值的数据，像逻辑数据、西文字符、汉字字符等都是非数值数据。`),
    section('基数（radix，base）')(
        p`基数是指进位计数制的「底数」或「基」。例如，二进制数的基数是「2」，十进制数的基数为「10」，十六进制的基数为「16」。`
    ),
    section('无符号整数（unsigned integer）')(
        p`当一个编码的所有二进位都用来表示数值时，该编码表示的就是无符号整数，也称为无符号数，可以看作正整数，常用于表示指针和地址等。`
    ),
    section('带符号整数（signed integer）')(p`带符号整数是指在计算机内部对正、负号进行了编码的整数，也称为有符号整数，通常用补码表示。`),
    section('定点数（fixed-point number）')(
        p`定点数是计算机中小数点固定在最左边或最右边的数，有定点整数和定点小数两种。定点整数的小数点总是约定在数的最右边，主要用来表示现实世界中的整数和浮点数中的指数。定点小数的小数点总是约定在数的最左边，主要用来表示浮点数中的尾数。`,
        p`定点数的编码方式有原码、反码、补码和移码；浮点数的尾数一般用原码小数来表示；浮点数的指数一般用移码来表示；而反码很少被使用，只用在某些特殊场合。`
    ),
    section('浮点数（floating-point number）')(
        p`浮点数是计算机中可以指定小数点在不同位置的数。任意一个浮点数 F 可写成 F=M×2E 的形式。这样，一个浮点数就可用两个定点数表示，M 称为浮点数的尾数（mantissa，significand），用一个定点小数来表示；E 称为浮点数的指数或阶码（exponent），用一个定点整数来表示。`
    ),
    section('原码（signed magnitude）')(
        p`原码由符号位直接跟数值位构成，也称「符号-数值」表示法。它的编码规则是：正号「+」用符号位「0」表示，负号「-」用符号位「1」表示，数值部分不变。这种编码比较简单，但计算机处理起来不方便，20 年代 50 年代以后，就不用它来表示整数。现代计算机中，一般用它来表示浮点数的尾数，如 IEEE 754 标准。`
    ),
    section('反码（one’s complement）')(p`一种对定点整数或定点小数进行二进制编码的编码方案。由于计算机处理反码没有补码方便，反码已很少被用到了。`),
    section('补码（two’s complement）')(
        p`补码编码规则是：正号「+」用符号位「0」表示，负号「-」用符号位「1」表示，正数的数值部分不变，负数的数值部分是「各位取反，末位加 1」。这种编码较原码复杂，但由于它是一种模运算系统，计算机处理起来很方便。常用补码表示带符号整数。`
    ),
    section('变形补码（four’s complement）')(
        p`变形补码是一种双符号位补码，又称为「模 4 补码」。双符号位可以用来检测定点整数是否发生溢出，左符号位为真正的符号位，右符号位用来判别是否溢出。采用「变形补码」进行溢出检测时的判断规则为：当结果的两个符号位不同时，发生溢出。双符号位通常用于保存运算过程中进到高位的数值部分。`
    ),
    section('移码（excess notation，biased notation）')(
        p`移码编码规则是：将真值加上一个偏置常数（bias）。因为在浮点数的加减运算中，要进行对阶操作，需要比较两个阶的大小。用移码表示阶码后，使得所有数的阶码都相当于一个正整数，比较大小时，只要按高位到低位顺序比较就行了，因而，移码主要用来表示浮点数的阶码，可以简化阶码的比较过程。`
    ),
    section('单精度浮点数（single precision floating point）')(
        p`指 IEEE 754 标准规定的 32 位浮点数格式表示的浮点数。阶码用 8 位移码表示，偏置常数为 127，尾数用原码表示，规格化浮点数的最高位「1」隐含不表示，显式表示的尾数有 23 位，所以一共有 24 位尾数。`
    ),
    section('双精度浮点数（double precision floating point）')(
        p`指 IEEE 754 标准规定的 64 位浮点数格式表示的浮点数。阶码用 11 位移码表示，偏置常数为 1023，尾数用原码表示，规格化浮点数的最高位「1」隐含不表示，显式表示的尾数有 52 位，所以一共有 53 位尾数。`
    ),
    section('机器 0（machine“0”）')(
        p`用一种专门的位序列表示「机器 0」。例如，IEEE 754 单精度浮点数中，用「00000000H」表示「+0」，用「80000000H」表示「-0」。当运算结果出现阶码过小时，计算机将该数近似表示为「机器 0」。`
    ),
    section('BCD 码（Binary Coded Decimal，BCD）')(p`十进制数用二进制编码的形式表示称为 BCD 码。`),
    section('逻辑数据（logic data）')(p`逻辑数据用来表示命题的「真」和「假」，分别用「1」和「0」来表示。进行逻辑运算时，按位进行。`),
    section('ASCII 码（American Standard Code for Information Interchange）')(
        p`目前计算机中使用最广泛的西文字符集及其编码，即美国标准信息交换码，简称 ASCII 码。`
    ),
    section('汉字输入码（Chinese character input code）')(
        p`汉字输入码是对每个汉字用一个标准键盘上按键的组合来表示的编码方式，一般分为数字编码（如区位码）、字音编码（如微软拼音、全拼）、字形编码（如五笔字型）和形音编码。`
    ),
    section('汉字内码（Chinese character code）')(
        p`汉字内码是用于汉字在计算机内部进行存储、查找、传输和处理而采用的编码方式，通常用 2～4 个字节表示一个汉字内码。`
    ),
    section('机器字长（machine word length）')(
        p`一个二进制位（比特，bit）是计算机内部信息表示的最小单位。而机器字长指的是特定计算机中 CPU 用于定点整数运算的数据通路的宽度，通常也就是 CPU 内定点数运算器和通用寄存器的位数。`
    ),
    section('编址单位（addressing unit）')(
        p`对主存单元编号时，具有相同编号的二进位数，主存单元的编号称为地址。通常的编址单位为 8，即字节。按字节编址时，编址单位为字节；按字编址时，编址单位为字。`
    ),
    section('字地址（word address）')(p`按字节编址时，一个字可能占用几个内存单元，字地址就是这几个连续内存单元地址中的最小值。`),
    section('最高有效位（Most Significant Bit，MSB）')(p`一个二进制数中的最高位。例如二进制数 1000 中的「1」。`),
    section('最低有效位（Least Significant Bit，LSB）')(p`一个二进制数中的最低位。例如二进制数 1110 中的「0」。`),
    section('最高有效字节（Most Significant Byte，MSB）')(p`一个二进制数中的最高字节。例如二进制数 1111 1111 0000 0000 1111 0000 中的 1111 1111。`),
    section('最低有效字节（Least Significant Byte，LSB）')(p`一个二进制数中的最低字节。例如二进制数 1111 1111 0000 0000 1111 0000 中的 1111 0000。`),
    section('大端方式（big endian）')(
        p`采用字节编址方式时，一个多字节数据（如 int、float 等类型数据）将占用多个主存单元。大端方式下，将数据字的最低有效字节 LSB 存放在大地址单元中，即字地址是 MSB 所在单元的地址。`
    ),
    section('小端方式（little endian）')(
        p`采用字节编址方式时，一个多字节数据（如 int、float 等类型数据）将占用多个主存单元。小端方式下，将数据字的最低有效字节 LSB 存放在小地址单元中，即字地址是 LSB 所在单元的地址。`
    ),
    section('边界对齐（boundary alignment）')(
        p`边界对齐是指要求数据的地址是相应的边界地址。例如，按字节编址时，4 字节长数据的地址应该是 4 的倍数，即最末两位总是 00，2 字节长数据的地址总是 2 的倍数。`
    ),
    section('逻辑移位（logical shift）')(
        p`逻辑移位是对无符号数进行的移位，即把无符号数看作一个逻辑数进行移位操作。左移时，高位移出，低位补 0；右移时，低位移出，高位补 0。`
    ),
    section('算术移位（arithmetic shift）')(
        p`算术移位是对带符号整数进行的，移位前后符号位不变。移位时，符号位不动，只是数值部分进行移位。左移时，高位移出，末位补 0，移出非符时，发生溢出；右移时，高位补符，低位移出。移出时，进行舍入操作。`
    ),
    section('循环（逻辑）移位（rotating shift）')(
        p`循环移位是一种逻辑移位，移位时把高（低）位移出的一位送到低（高）位，即左移时，各位左移一位，并把最左边的位移到最右边；右移时，各位右移一位，并把最右边的位移到最左边。`
    ),
    section('扩展操作（extending）')(
        p`在计算机内部，有时需要将一个取来的短数扩展为一个长数，此时要进行填充（扩展）处理。扩展操作有「零扩展」和「符号扩展」两种。`
    ),
    section('零扩展（zero extending）')(p`对无符号整数进行高位补 0 的操作称为「零扩展」。`),
    section('符号扩展（sign extending）')(p`对补码整数在高位直接补符的操作称为「符号扩展」。`),
    section('半加器（half adder）')(p`只考虑本位两个加数而不考虑低位进位来生成本位和的一位加法器。`),
    section('全加器（full adder，（3，2）adder）')(p`不仅考虑本位两个加数而且考虑低位进位来生成本位和的一位加法器。`),
    section('加法器（adder）')(p`加法器是能对两个 n 位无符号整数进行相加的 n 位加法运算部件。`),
    section('整数加减运算部件（integer adder/substractor）')(
        p`整数加减运算部件是能对带符号整数和无符号整数进行加运算和减运算的运算电路，基于基本加法器实现，可生成溢出标志、零标志、符号标志和进位/借位等各个标志信息。`
    ),
    section('算术逻辑部件（Arithmetic Logic Unit，ALU）')(
        p`算术逻辑部件是用于执行各种基本算术运算和逻辑运算的部件，其核心部件是加法器，有两个操作数输入端和低位进位输入端，一个运算结果输出端和若干标志信息（如零标志、溢出标志等）输出端。因为 ALU 能进行多种运算，因此，需要通过相应的操作控制输入端来选择进行何种运算。`,
        p`零标志 ZF，溢出标志 OF，进位/借位标志 CF，符号标志 SF`,
        p`ALU 部件的输出除了运算结果外，还有一组状态标志信息。例如，ZF（Zero Flag）为 1 时表示结果为 0；OF（Overflow Flag）为 1 时表示结果溢出；CF（Carry Flag）为 1 表示在最高位产生了进位或借位；SF（Sign Flag）和符号位保持一致，若为 1，则表示结果为负数。`
    ),
    section('布斯算法（Booth’s algorithm）')(
        p`布斯算法是一种一位补码乘法算法，用于带符号数的乘法运算，由布斯（Booth）提出。算法的基本思想是在乘数的末位添加一个「0」，乘数中出现的连续「0」和连续「1」处不进行任何运算；出现「10」时，做减法；出现「01」时，做加法。每次只做一位乘法，因而每一步都右移一位。`
    ),
    section('对阶（align exponent）')(
        p`浮点数加/减运算时，在尾数相加/减之前所进行的操作称为对阶。对阶时，需要比较两个阶的大小。阶小的那个数的尾数右移，阶码增量。右移一次，阶码加 1，直到两数的阶码相等为止。`
    ),
    section('溢出（overflow）')(
        p`溢出是指一个数比给定的格式所能表示的最大值还要大，或比最小值还要小的现象。因为无符号数、带符号整数和浮点数的位数是有限的，所以都有可能发生溢出，但判断溢出的具体方法不同。`
    ),
    section('阶码下溢（underflow）')(
        p`在浮点数运算中，当运算结果的指数（阶）比最小允许值还小，此时，运算结果发生阶码下溢，也即运算结果的实际值位于 0 和绝对值最小的可表示数之间。通常机器会把阶码下溢时浮点数的值置为 0。因此，这种情况下结果并没有发生错误，只是得到了一个近似于 0 的值，因而无需进行溢出处理。`
    ),
    section('阶码上溢（overflow）')(
        p`在浮点数运算中，当运算结果的指数（阶）超过了最大允许值，此时，浮点数发生了上溢，即向 ∞ 方向溢出。如果结果是正数，则发生正上溢，有的机器把值置为 +∞；如果是负数，则发生负上溢，有的机器把值置为-∞。这种情况为软件故障，通常要引入溢出故障处理程序来处理。`
    ),
    section('规格化数（normalized number）')(
        p`为了使浮点数中能尽量多地表示有效位数，一般要求运算结果用规格化数形式表示。规格化浮点数的尾数小数点后的第一位一定是个非零数。因此，对于原码编码的尾数来说，只要看尾数的第一位是否为 1 就行；对于补码表示的尾数，只要看符号位和尾数最高位是否相反。`
    ),
    section('左规（left normalize）')(
        p`在浮点数运算中，当一个尾数的数值部分的高位出现 0 时，尾数为非规格化形式。此时，进行「左规」操作：尾数左移一位，阶码减 1，直到尾数为规格化形式为止。`
    ),
    section('右规（right normalize）')(
        p`在浮点数运算中，当尾数最高有效位有进位时，发生尾数溢出。此时，进行「右规」操作：尾数右移一位，阶码加 1，直到尾数为规格化形式为止。右规过程中，要判断是否发生溢出。此时，只要阶码不发生上溢，那么浮点数就不会溢出。`
    ),
    section('舍入（rounding）')(
        p`舍入是指数值数据右部的低位数据需要丢弃时，为保证丢弃后数值误差尽量小而考虑的一种操作。例如，定点整数「右移」时、浮点加/减运算中某数「对阶」时、浮点运算结果「右规」时都会涉及舍入。`
    ),
    section('保护位（guard bit）和舍入位（rounding bit）')(
        p`为了使浮点数的有效数据位在右移时最大限度地保证不丢失，一般在运算过程中得到的中间值后面增加若干数据位，这些位用来保存右移后的有效数据，因此，是添加的附加位。增设附加位后，能保证运算结果具有一定的精度，但最终必须将附加位去掉，以得到规定格式的浮点数，此时要考虑舍入。在 IEEE 754 标准中规定，浮点运算的中间结果可以额外多保留两位附加位，这两位分别称为保护位和舍入位。`
    ),
    section('粘位（sticky bit）')(
        p`IEEE 754 标准中规定，为了更进一步提高计算精度，可以在舍入位右边再增加一位，称为「粘位」，只要舍入位的右边还有任何非零数位，则粘位为 1，否则为 0。`
    )
).elem
