import { p, precode, section } from '@src/components/@write'
const title = '2.4　常见问题解答'
const page = section(title)(
    section('1.真值和机器数的关系是什么？')(
        p`答：在计算机内部用二进制编码表示的数称为机器数，而机器数真正的值（即原来带有正负号的数）称为机器数的真值，所以，它们之间的关系就是同一个数据的两种不同表示形式。`
    ),
    section('2.什么是编码？')(
        p`答：编码是指用少量简单的基本符号，对大量复杂多样的信息进行一定规律的组合。基本符号的种类和组合规则是信息编码的两大要素。例如，用 10 个阿拉伯数字表示数值，电报码中用 4 位十进制数字表示汉字，等等，都是编码的典型例子。计算机内部处理的所有信息都是「数字化编码」了的信息。`
    ),
    section('3.什么是数字化编码？')(
        p`答：「数字化编码」就是对感觉媒体信息（如数值、文字、图像、声音、视频等信息）进行定时采样，将现实世界中的连续信息转换为计算机中离散的「样本」信息，然后对这些离散的「样本」信息进行二进制编码。`
    ),
    section('4.计算机内部为什么用二进制来编码所有信息？')(
        p`答：主要有以下三方面的原因。`,
        p`① 二进制系统只有两个基本符号：「0」和「1」，所以，它的基本符号少，易于用稳态电路实现。`,
        p`② 二进制的编码/计数/运算等规则简单。`,
        p`③ 二进制中的「0」和「1」与逻辑命题的「真」和「假」的对应关系简单，为在计算机中实现逻辑运算和程序中的逻辑判断提供了便利的条件，特别是能通过逻辑门电路方便地实现算术运算。`
    ),
    section('5.计算机内部都用二进制表示信息，为什么还要引入八进制和十六进制？')(
        p`答：计算机内部在进行信息的存储、传送和运算时，都是以二进制形式来表示信息的。但在屏幕上或书本上书写信息时，由于二进制信息位数多，阅读、记忆不方便，而十六进制、八进制和二进制的对应关系简单，又便于阅读、记忆和书写，所以引入十六进制或八进制，使得人们在开发、调试程序和阅读机器内部代码时，能方便地用八进制或十六进制来等价表示二进制信息。`
    ),
    section('6.如何表示一个数值数据？计算机中的数值数据都是二进制数吗？')(
        p`答：在计算机内部，数值数据的表示方法有以下两大类。`,
        p`① 直接用二进制数表示。二进制数分为无符号数和有符号数，有符号数又分为定点整数表示和浮点数表示。无符号数用来表示无符号整数（如地址等信息）；定点整数用来表示带符号整数；浮点数用来表示实数。`,
        p`② 采用二进制编码的十进制数（即 Binary Coded Decimal Number，简称 BCD 码）来表示整数，BCD 码的编码方案很多，但一般都采用 8421 码（也称为 NBCD 码）来表示。`,
        p`因此，计算机中的数值数据虽然都用二进制来编码表示，但不全是二进制数，也有用十进制数表示的。因而有些处理器的指令类型中，就有对应的二进制加法指令和十进制加法指令。`
    ),
    section('7.为什么要引入无符号数表示？')(
        p`答：因为在有些情况下只要对正整数进行运算，且结果不出现负值，此时，可以用无符号数表示变量。例如，在进行地址或指针运算时可用无符号数。`
    ),
    section('8.在高级语言程序中定义的 unsigned 型数据是怎么表示的？')(
        p`答：unsigned 型数据就是无符号数，直接用二进制对数值进行编码得到的就是无符号数。`
    ),
    section('9.为什么无符号数运算时结果可能会发生「溢出」？什么叫无符号数的「溢出」？')(
        p`答：计算机的机器字长总是有限的，因而机器数的位数有限，使得可表示的数的个数有限。对于 n 位二进制数，只能表示 2n 个不同的数，当运算结果超过 n 位数时就可能发生溢出。`,
        p`对于无符号数来说，计算机运算过程中一般保留低 n 位，舍弃高位。这样会产生两种结果：`,
        p`① 剩下的低 n 位数不能正确表示运算结果。这种情况意味着运算的结果超出了计算机能表达的范围，有效数值进到了第 n+1 位，我们称此时发生了「溢出」现象。例如，对于 4 位无符号数相加运算，当计算 14+3 时就发生溢出，即 1110+0011=10001，结果中第一位 1 是数值部分，这个 1 丢弃后结果就不对了。`,
        p`② 剩下的低 n 位数能正确表达计算结果，也即高位的舍去并不影响其运算结果。例如，对于 4 位无符号数相减运算，当计算 14-3 时，用 14 加-3 的补码来实现，即 1110+1101=11011，结果中第一位 1 不是数值部分，这个 1 丢弃后的结果是十进制的 11，因此是正确的。`,
        p`「对一个多于 n 位的数丢弃高位而保留低 n 位数」这样一种处理，实际上等价于「将这个多于 n 位的数去除以 2n，然后丢弃商保留其余数」的操作。这种操作运算就是「模运算」。在一个模运算系统中，运算的结果最终都是丢弃高位而保留低位。所以，只要不是「溢出」（即只要真正的值不会进到第 n+1 位），结果就是正确的。这是模运算系统的特点。`
    ),
    section('10.为什么现代计算机都用补码来表示整数？')(
        p`答：和原码、反码相比，用补码表示定点整数有四个好处：① 符号位可以和数值位一起参加运算；② 补码可以实现模运算，即可用加法方便地实现减法运算；③ 零的表示唯一；④ 可以多表示一个最小负数。所以，现代计算机中都采用补码来表示定点整数。`
    ),
    section('11.n 位二进制补码整数的模是多少？数的表示范围是多什么？')(
        p`答：n 位二进制补码整数的模是 2n，表示其运算结果只保留低 n 位，多于 n 位的高位部分取模后要被丢弃掉，其数值范围为-2（n-1）～+2（n-1）-1。`
    ),
    section('12.在高级语言编程时定义的 short/int/long 型数据是怎么表示的？')(
        p`答：int 型数据就是定点整数，现代计算机一般用补码表示。int 型数据的位数与运行平台以及编译器有关，目前一般是 32 位或 16 位。long 型数据和 short 型数据也都是定点整数，用补码表示，只是位数不同，分别是长整型和短整型数。`
    ),
    section('13.在 C 语言程序中，关系表达式「-2147483648==2147483648U」的结果为什么为「真」？')(
        p`答：关系表达式「-2147483648==2147483648U」的左边是负数，右边是正数，因此，左右两数看似不等，结果似乎应该为「假」。但是，在 C 语言中，如果在一个表达式中同时有 unsigned int（无符号整数）类型和 int（带符号整数）类型数据，那么，C 编译器会隐含地将 int 型数据强制类型转换为无符号整数。在上面的关系表达式运算中，对于左边的数「-2147483648」，编译器会先把 2147483648 转换为机器数「1000 0000 0000 0000 0000 0000 0000 0000」，然后将负号「-」转换为一条「取负指令」，得到对应的机器数还是「1000 0000 0000 0000 0000 0000 0000 0000」，将其解释成无符号整数，其值为 231，和右边的无符号整数「2147483648U」的值完全相同，因而结果为「真」。`
    ),
    section('14.定点整数在数轴上分布的点之间都是等距的吗？')(
        p`答：是的。定点整数在数轴上分布的点总是在整数值上，即[…，-5，-4，-3，-2，-1，0，1，2，3，4，5，…]，相邻数据间隔总是 1。`
    ),
    section('15.为什么要引入浮点数表示？')(p`答：因为定点数不能表示实数，而且表数范围小，所以，要引入浮点数表示。`),
    section('16.为什么浮点数的阶（指数）要用移码表示？')(
        p`答：因为在浮点数的加减运算中，要进行对阶操作，需要比较两个阶的大小。移码表示的实质就是把阶加上一个偏置常数，使得所有数的阶码都是一个正整数，比较大小时，只要按高位到低位顺序比较就行了，因而，引入移码可以简化阶的比较过程。`
    ),
    section('17.浮点数如何表示 0？')(
        p`答：用一种专门的位序列表示 0，例如，IEEE 754 单精度浮点数中，用「0000 0000H」表示 +0，用「8000 0000H」表示-0。当运算结果出现阶码过小时，计算机将该数近似表示为 0，称为「机器 0」。`
    ),
    section('18.现代计算机中采用什么标准来表示浮点数？')(
        p`答：早期的计算机各自采用不同的浮点数表示格式，因而，在不同计算机之间进行数据交换时，就会发生数据不统一的问题。所以，专门制定了 IEEE 754 标准，以规定计算机中的浮点数表示格式。现代计算机中都采用 IEEE 754 标准来表示浮点数。`
    ),
    section('19.为什么浮点数要采用规格化形式表示？')(p`答：为了使浮点数中能尽量多地表示有效位数，提高浮点数运算的精度，而且规格化形式具有唯一性。`),
    section('20.如何判断一个浮点数是否是规格化数？')(
        p`只要看转换为真值后，其尾数的第一位是否一定是非零数。因此，对于原码编码的尾数来说，只要看尾数的数值部分第一位是否为 1 就行。`
    ),
    section('21.浮点数表示的精度和数值范围取决于什么？')(
        p`答：浮点数的精度取决于尾数的位数，而数值范围取决于阶码的位数。在浮点数总位数不变的情况下，阶码位数越多，则尾数位数越少。即表数范围越大，则精度越差（数变稀疏）。`
    ),
    section('22.基数的大小对表数范围和精度有什么影响？')(p`答：基数越大，则范围越大，但精度变差（数变稀疏）。`),
    section('23.在高级语言编程中，float 和 double 型数据是怎么表示的？')(
        p`答：现代计算机用 IEEE 754 标准表示浮点数，其中 32 位单精度浮点数就是 float 型，64 位双精度浮点数就是 double 型。`
    ),
    section('24.在高级语言编程中，long double 型数据是怎么表示的？')(
        p`答：long double 型数据的长度和格式随编译器和处理器类型的不同而有所不同。例如，Microsoft Visual C++6.0 版本以下的编译器都不支持该类型，因此，用其编译出来的目标代码中 long double 和 double 一样，都是 64 位双精度；在 IA-32 上使用 GCC 编译器时，long double 类型数据采用 Intel x86 FPU 的 80 位双精度扩展格式（1 位符号位 s、15 位阶码 e、1 位显式首位有效位（explicit leading significand bit）j 和 63 位尾数 f）表示；在 SPARC 和 PowerPC 处理器上使用 GCC 编译器时，long double 类型数据采用相应的 128 位双精度扩展格式（1 位符号位 s、15 位阶码 e 和 112 位尾数 f，采用隐藏位，故有效位数为 113 位）表示。`
    ),
    section(
        '25.C 语言程序中，为什么关系表达式「123456789==（int）（float）123456789」的结果为「假」，而关系表达式「123456==（int）（float）123456」和「123456789==（int）（double）123456789」的结果都为「真」？'
    )(
        p`答：首先应该明白，在 C 语言中，float 类型对应 IEEE 754 单精度浮点数格式，也即 float 型数据的有效位数只有 24 位（相当于有 7 位十进制有效位数）；double 类型对应 IEEE 754 双精度浮点数格式，有效位数有 53 位（相当于有 17 位十进制有效位数）；int 类型为 32 位整数，其有效位数为 31 位（最大数为 2147483647，相当于 10 位十进制有效位数）。`,
        p`整数 123456789 的有效位数为 9 位，转换为 float 型数据后肯定发生了有效位数丢失，再转换为 int 型数据时，已经不是 123456789 了，所以，关系表达式「123456789==（int）（float）123456789」的结果为假。`,
        p`数据改为 123456 后，有效位数只有 6 位，转换为 float 型数据后有效位数没有丢失，因而数据没变，再转换为 int 型数据时，还是 123456，所以，关系表达式「123456==（int）（float）123456」的结果为真。`,
        p`整数 123456789 的有效位数为 9 位，转换为 double 型数据后，不会发生有效位数丢失，再转换为 int 型数据时，还是 123456789，所以，关系表达式「123456789==（int）（double）123456789」的结果为真。`
    ),
    section('26.位数相同的定点数和浮点数中，可表示的浮点数个数比定点数个数多吗？')(
        p`答：不是的。可表示的数据个数取决于编码所采用的位数。编码位数一定，则编码出来的数据个数就是一定的。n 位编码最多只能表示 2n个数，所以，对于相同位数的定点数和浮点数来说，可表示的数据个数应该一样多。但是，有时由于一个值可能有两个或多个编码对应，编码个数会有少量差异。`
    ),
    section('27.如何进行 BCD 码的编码？')(
        p`答：每位十进制数的取值可以是 0、1、2、…、9 这十个数之一，因此，每一个十进制数位必须至少有 4 位二进制位来表示。而 4 位二进制位可以组合成 16 种状态，去掉 10 种状态后还有 6 种冗余状态，所以从 16 种状态中选取 10 种状态表示十进制数位 0～9 的方法很多，可以产生多种 BCD 码方案。大的方面可分为有权码和无权码两种。`,
        p`有权码指表示每个十进制数位的 4 个二进制数位（称为基 2 码）都有一个确定的权。8421 码是最常用的十进制有权码；无权码指表示每个十进制数位的 4 个基 2 码没有确定的权。`
    ),
    section('28.逻辑数据在计算机中如何表示？如何运算？')(
        p`答：逻辑数据用来表示命题的「真」和「假」，分别用「1」和「0」来表示。进行逻辑运算时，按位进行。`
    ),
    section('29.汉字的区位码、国标码和机内码有什么区别？')(
        p`答：GB 2312—1980 字符集由 94 行、94 列组成，行号称为区号，列号称为位号，各占 7 位，共 14 位，区号在左、位号在右，称为汉字的区位码，它指出了该汉字在码表中的位置。`,
        p`汉字的国标码是将区号、位号各加上 32（即十六进制的 20H）后，再在前后各 7 位前加 0。`,
        p`汉字的内码需 2 个字节才能表示，可以在国标码的基础上产生汉字机内码，一般是将国标码的两个字节的第一位设置成「1」。`,
        p`例如，已知一个汉字的国标码为 343AH，前后两个字节各减 32（20H）得到区位码为：343AH-2020H=141AH，所以区号为 20（14H），位号为 26（1AH）；机内码是将国标码的两个字节的最前面一位变为「1」，因此，机内码为 B4BAH。`
    ),
    section('30.MSB（LSB）表示最高（低）有效字节还是最高（低）有效位？')(
        p`答：MSB 的含义既可能是最高有效字节（Most Significant Byte），也可能是最高有效位（Most Significant Bit），具体表示哪一个含义既要看上下文。同样，LSB 的含义既可能是最低有效字节（Least Significant Byte），也可能是最低有效位（Least Significant Bit）。`
    ),
    section('31.有时用「字」表示数据的宽度，一个「字」到底有多少位？')(
        p`答：除了用「比特（bit）」和「字节（Byte）」来表示一个数据的宽度外，有时也用「字（Word）」来表示数据宽度的单位。不同的计算机，其「字」的长度和组成不完全相同，有的由 2 个字节组成，有的由 4 个、8 个甚至 16 个字节组成。`
    ),
    section('32.一个「字」的宽度就是一个「机器字长」吗？')(
        p`答：不是。「机器字长」是计算机的一个非常重要的指标。通常称 32 位机器或 64 位机器，就是指机器的字长是 32 位或 64 位。一般情况下，机器字长定义为 CPU 中一次能够处理的二进制整数的位数，实际上就是 CPU 中整数运算数据通路的位数。`,
        p`「字」作为信息宽度的计量单位，对于某个系列机来说，其字宽总是固定的。例如，在 80x86 系列中，一个字的宽度为 16 位，因此，32 位是双字，64 位是四字。在 IBM 303X 系列中，一个字的宽度为 32 位，所以 16 位为半字，32 位为单字，64 位为双字。`,
        p`一个「字」的宽度可以不等于机器字长。例如，在 Intel 微处理器中，从 80386 开始就至少都是 32 位机器了，即机器字长至少为 32 位，但其字的宽度都定义为 16 位。`
    ),
    section('33.在表示存储容量和带宽时经常用到 KB、MB、GB、TB 等表示数据量的单位，为什么有的时候 1MB 等于 106字节，有的时候又等于 220字节呢？')(
        p`答：当表示二进制存储容量时，度量单位用 2 的幂次，例如，若主存容量为 1GB，则表示主存有 230 字节。当描述距离、频率等数值时，通常用 10 的幂次表示，因而在由时钟频率计算得到的总线带宽或外设数据传输率中，度量单位表示的也是 10 的幂次。例如，若总线带宽为 1GB/s，表示总线每秒传输 109字节。为区分这种差别，通常用 K 表示 1024，用 k 表示 1000，而其他前缀字母均为大写，表示的大小由其上下文决定。`
    ),
    section('34.补码加法器如何实现？')(
        p`答：两个 n 位补码进行加法运算的规则是：两个 n 位补码直接相加，并将结果中最高位的进位丢掉，也即采用模运算方式。显然，可用一个 n 位无符号加法器来生成各位的和。最终的结果是否正确，取决于结果是否溢出，只要结果不溢出，则结果一定是正确的。因此，补码加法器只要在无符号加法器的基础上再增加「溢出判断电路」即可。`
    ),
    section('35.在补码加法器中，如何实现补码减法运算？')(
        p`答：补码减法的规则是：两个数差的补码可用第一个数的补码加上第二个数负数的补码得到。由此可见，减法运算可在加法器中运行。只要在加法器的第二个输入端输入减数的负数的补码。求一个数的负数的补码电路称为「负数求补电路」。可以通过「各位取反、末位加 1」来实现「负数求补电路」。`
    ),
    section('36.现代计算机中是否要考虑原码加/减运算？为什么？')(
        p`答：因为现代计算机中浮点数采用 IEEE 754 标准，浮点数的尾数都用原码表示，所以在进行两个浮点数加减运算时，必须考虑原码的加减运算。`
    ),
    section('37.定点整数运算要考虑加保护位和舍入吗？')(
        p`答：不需要。整数运算的结果还是整数，没有误差，无需考虑加保护位，也无需考虑舍入。但运算结果可能会「溢出」。`
    ),
    section('38.如何判断带符号整数运算结果是否溢出？')(
        p`答：带符号整数用补码表示，对于单符号补码（即 2-补码）和双符号补码（即 4-补码，变形补码），其溢出判断方式不同。变形补码运算的溢出判断规则为：「当结果的两个符号位不同时，发生溢出」；单符号补码运算时，异号数相加不会溢出，而对于同号数相加，则有两种判断规则。规则 1 为：「若结果的符号与两个加数的符号不同，则发生溢出」，规则 2 为：「若最高位的进位和次高位的进位不同，则发生溢出」。`
    ),
    section('39.在计算机中，乘法和除法运算如何实现？')(
        p`答：乘法和除法运算是通过加、减运算和左、右移位运算来实现的。只要用加法器和移位寄存器在控制逻辑的控制下就可以实现乘除运算。也可用专门的乘法器和除法器实现。`
    ),
    section('40.浮点数如何进行舍入？')(
        p`答：舍入方法选择的原则是：① 尽量使误差范围对称，使得平均误差为 0，即有舍有入，以防误差积累。② 方法要简单，以加快速度。`,
        p`IEEE 754 标准有 4 种舍入方式：① 就近舍入。舍入为最近可表示的数，若结果值正好落在两个可表示数的中间，则选择舍入结果为偶数。② 正向舍入。朝 +∞ 方向舍入，即取右边的那个数。③ 负向舍入。朝-∞ 方向舍入，即取左边的那个数。④ 截断舍入。朝 0 方向舍入，即取绝对值较小的那个数。`
    ),
    section('41.在 C 语言程序中，为什么以下程序段最终的 f 值为 0，而不是 2.5？')(
        precode(`float f = 2.5 + 1e10;
    f = f-1e10 ;
`)(),
        p`答：首先，float 类型采用 IEEE 754 单精度浮点数格式表示，因此，最多有 24 位二进制有效位数。因为 1e10=1010=10×103×106，在数量级上大约相当于 23×210×220=233，而 2.5 的数量级为 21，因此，在计算 2.5+1e10 进行对阶时，两数阶码的差为 32，也就是说，2.5 的尾数要向右移 32 位，从而使得 24 位有效数字全部丢失，尾数变为全 0，再与 1e10 的尾数相加时结果就是 1e10 的尾数，因此 f=2.5+1e10 的运算结果仍为 1e10，这样，再执行 f=f-1e10 时结果就为 0。这个例子就是典型的「大数吃小数」的例子。`
    )
).elem
