import { p, section, precode } from '@src/components/@write'
import { multipleChoice, answer } from '@src/components/@questionnaire'
const title = '2.5　单项选择题'
const page = section(title)(
    multipleChoice('1.计算机中的所有信息都以二进制表示的原因是（　　）。')(
        p`信息处理方便`,
        p`运算速度快`,
        p`节约元器件`,
        answer(p`物理器件特性所致`)
    ),
    multipleChoice('2.引入八进制和十六进制的目的是（　　）。')(
        p`节约元件`,
        p`实现方便`,
        p`可以表示更大范围的数`,
        answer(p`用于等价地表示二进制，便于阅读和书写`)
    ),
    multipleChoice('3.108 对应的十六进制形式是（　　）。')(answer(p`6CH`), p`B4H`, p`5CH`, p`63H`),
    multipleChoice('4.以下给出的各种进位计数制的数中，最小的数为（　　）。')(p`（10010110）2`, p`（63）8`, p`（10010110）BCD`, answer(p`（2F）16`)),
    multipleChoice('5.以下给出的各种进位计数制的数中，最小的数为（　　）。')(p`（11100101）2`, p`（93）10`, p`（10010010）BCD`, answer(p`（5A）16`)),
    multipleChoice('6.负零的补码表示为（　　）。')(p`100…00`, answer(p`000…00`), p`011…11`, p`111…11`),
    multipleChoice('7.[X]补=X0.X1X2…Xn（n 为整数），它的模是（　　）。')(p`2n-1`, p`2n`, p`1`, answer(p`2`)),
    multipleChoice('8.[X]补=X0X1X2…Xn（n 为整数），它的模是（　　）。')(answer(p`2n+1`), p`2n`, p`2n+1`, p`2n-1`),
    multipleChoice('9.以下编码中，零的表示形式是唯一的编码是（　　）。')(p`反码`, p`原码`, answer(p`补码`), p`原码和补码`),
    multipleChoice('10.以下有关补码和移码（偏置常数为 2n-1）关系的叙述中，错误的是（　　）。')(
        p`相同位数的补码和移码表示具有相同的表数范围`,
        answer(p`零的补码和移码表示相同`),
        p`同一个数的补码和移码表示，其数值部分相同，而符号相反`,
        p`一般用移码表示浮点数的阶，而用补码表示定点整数`
    ),
    multipleChoice(
        '11.以下是一些关于编码表示特点的叙述：',
        p`① 零的表示是唯一的。`,
        p`② 符号位可以和数值部分一起参加运算。`,
        p`③ 和其真值的对应关系简单、直观。`,
        p`④ 减法可用加法来实现。`,
        p`其中哪些选项是补码表示的特点？（　　）`
    )(p`仅 ① 和 ②`, p`仅 ① 和 ③`, p`仅 ① 和 ② 和 ③`, answer(p`仅 ① 和 ② 和 ④`)),
    multipleChoice('12.假定某数 X=-0100 1010B，在计算机内部的表示为 1011 0110B，则该数所用的编码方法是（　　）。')(
        p`原码`,
        p`反码`,
        answer(p`补码`),
        p`移码`
    ),
    multipleChoice('13.设寄存器位数为 8 位，机器数采用补码形式（含一位符号位），则十进制数-26 存放在寄存器中的内容为（　　）。')(
        p`26H`,
        p`9BH`,
        answer(p`E6H`),
        p`5AH`
    ),
    multipleChoice('14.-1029 的 16 位补码用十六进制表示为（　　）。')(p`0405H`, p`7BFBH`, p`8405H`, answer(p`FBFBH`)),
    multipleChoice(
        '15.考虑以下 C 语言代码：',

        precode(`short si= -8196;
unsigned short usi=si;
`)(),

        p`执行上述程序段后，usi 的值是（　　）。`
    )(p`8196`, p`34572`, p`57339`, answer(p`57340`)),
    multipleChoice('16.若[X]原=1.x1x2x3x4，其中，小数点前面一位是符号位，符号位为 1 时表示负数。当满足（　　）时，X>-1/2 成立。')(
        p`x1必须为 1，x2、x3、x4至少有一个为 1`,
        p`x1必须为 1，x2、x3、x4任意`,
        p`x1必须为 0，x2、x3、x4至少有一个为 1`,
        answer(p`x1必须为 0，x2、x3、x4任意`)
    ),
    multipleChoice('17.设 X=-1011，则 8 位补码[X]补为（　　）。')(p`1000 0101`, p`1000 1011`, answer(p`1111 0101`), p`1111 1011`),
    multipleChoice('18.16 位无符号数所能表示的数值范围是（　　）。')(answer(p`0～（216-1）`), p`0～（215-1）`, p`0～216`, p`0～215`),
    multipleChoice('19.16 位补码整数所能表示的范围是（　　）。')(
        answer(p`-215～+（215-1）`),
        p`-（215-1）～+（215-1）`,
        p`-216～+（216-1）`,
        p`-（216-1）～+（216-1）`
    ),
    multipleChoice('20.若浮点数尾数用补码表示，则下列数中为规格化尾数形式的是（　　）。')(
        p`1.110 0000`,
        p`0.011 1000`,
        p`0.010 1000`,
        answer(p`1.000 1000`)
    ),
    multipleChoice('21.若浮点数尾数用原码表示，则下列数中为规格化尾数形式的是（　　）。')(
        answer(p`1.110 0000`),
        p`0.011 1000`,
        p`0.010 1000`,
        p`1.000 1000`
    ),
    multipleChoice('22.用于表示浮点数阶码的编码通常是（　　）。')(p`原码`, p`补码`, p`反码`, answer(p`移码`)),
    multipleChoice('23.假定某数采用 IEEE 754 单精度浮点数格式表示为 4510 0000H，则该数的值是（　　）。')(
        p`（+1.125）10×210`,
        answer(p`（+1.125）10×211`),
        p`（+0.125）10×211`,
        p`（+0.125）10×210`
    ),
    multipleChoice('24.假定某数采用 IEEE 754 单精度浮点数格式表示为 C820 0000H，则该数的值是（　　）。')(
        p`（-1.01）10×217`,
        p`（-1.01）10×2144`,
        answer(p`（-1.25）10×217`),
        p`（-1.25）10×2144`
    ),
    multipleChoice(
        '25.假定变量 i、f 的数据类型分别是 int、float。已知 i=12345，f=1.2345e3，则在一个 32 位机器中执行下列表达式时，结果为「假」的是（　　）。'
    )(p`i==（int）（float）i`, p`i==（int）（double）i`, answer(p`f==（float）（int）f`), p`f==（float）（double）f`),
    multipleChoice(
        '26.IBM 370 的短浮点数格式中，总位数为 32 位，左边第一位（b0）为数符，随后 7 位（b1～b7）为阶码，用移码表示，偏置常数为 64，右边 24 位（b8～b31）为 6 位十六进制原码小数表示的尾数，规格化尾数形式为 0.x1x2x3x4x5x6，x1～x6为十六进制表示，最高位 x1为非 0 数，基为 16。若将十进制数-265.625 用该浮点数规格化形式表示，则应表示为（　　）。（用十六进制形式表示）'
    )(answer(p`C310 9A00H`), p`4310 9A00H`, p`8310 9A00H`, p`0310 9A00H`),
    multipleChoice(
        '27.假定两种浮点数表示格式的位数都是 32 位，但格式 1 的阶码长、尾数短，格式 2 的阶码短、尾数长，其他所有规定都相同，则它们可表示的数的精度和范围为（　　）。'
    )(
        p`两者可表示的数的范围和精度均相同`,
        p`格式 1 可表示的数的范围更小，但精度更高`,
        answer(p`格式 2 可表示的数的范围更小，但精度更高`),
        p`格式 1 可表示的数的范围更大，且精度更高`
    ),
    multipleChoice('28.在一般的计算机系统中，西文字符编码普遍采用（　　）。')(p`BCD 码`, answer(p`ASCII 码`), p`格雷码`, p`CRC 码`),
    multipleChoice(
        '29.假定某计算机按字节编址，采用小端方式，有一个 float 型变量 x 的地址为 FFFF C000H，x=12345678H，则在内存单元 FFFF C001H 中存放的内容是（　　）。'
    )(p`1234H`, p`34H`, answer(p`56H`), p`5678H`),
    multipleChoice('30.以下有关机器字长的叙述中，错误的是（　　）。')(
        p`机器字长是指 CPU 中定点运算数据通路宽度`,
        p`机器字长一般与 CPU 中寄存器的位数有关`,
        p`机器字长决定了定点整数的表示范围`,
        answer(p`机器字长对计算机硬件的造价没有影响`)
    ),
    multipleChoice('31.以下关于计算机中存储器容量单位的叙述中，错误的是（　　）。')(
        p`最小的计量单位为位（bit），表示一位「0」或「1」`,
        p`最基本的计量单位是字节（Byte），一个字节等于 8bit`,
        answer(p`一台计算机的编址单位、指令字长和数据字长都一样，且是字节的整数倍`),
        p`主存容量为 1KB，其含义是主存中能存放 1024 个字节的二进制信息`
    ),
    multipleChoice('32.假定下列字符编码中含有奇偶检验位，但没有发生数据错误，那么采用奇校验的字符编码是（　　）。')(
        p`0101 0011`,
        p`0110 0110`,
        answer(p`1011 0000`),
        p`0011 0101`
    ),
    multipleChoice('33.8 位无符号整数 1001 0101 右移一位后的值为（　　）。')(answer(p`0100 1010`), p`0100 1011`, p`1000 1010`, p`1100 101`),
    multipleChoice('34.8 位补码定点整数 1001 0101 右移一位后的值为（　　）。')(p`0100 1010`, p`0100 1011`, p`1000 1010`, answer(p`1100 1010`)),
    multipleChoice('35.8 位补码定点整数 1001 0101 左移一位后的值为（　　）。')(p`1010 1010`, p`0010 1010`, p`0010 1011`, answer(p`溢出`)),
    multipleChoice('36.8 位补码定点整数 1001 0101 扩展 8 位后的值用十六进制表示为（　　）。')(p`0095H`, p`9500H`, answer(p`FF95H`), p`95FFH`),
    multipleChoice('37.原码定点小数 1.1001 0101 扩展 8 位后的值为（　　）。')(
        p`1.0000 0000 1001 0101`,
        answer(p`1.1001 0101 0000 0000`),
        p`1.1111 1111 1001 0101`,
        p`1.1001 0101 1111 1111`
    ),
    multipleChoice(
        '38.考虑以下 C 语言代码：',

        precode(`short si= -8196;
int i=si;
`)(),

        p`执行上述程序段后，i 的机器数表示为（　　）。`
    )(p`0000 9FFCH`, p`0000 DFFCH`, p`FFFF 9FFCH`, answer(p`FFFF DFFCH`)),
    multipleChoice('39.CPU 中能进行算术和逻辑运算的最基本运算部件是（　　）。')(p`多路选择器`, p`移位器`, p`加法器`, answer(p`ALU`)),
    multipleChoice('40.ALU 的核心部件是（　　）。')(p`多路选择器`, p`移位器`, answer(p`加法器`), p`寄存器`),
    multipleChoice('41.在补码加/减运算部件中，无论采用双符号位还是单符号位，必须有（　　）电路，它一般用异或门来实现。')(
        p`译码`,
        p`编码`,
        answer(p`溢出判断`),
        p`移位`
    ),
    multipleChoice(
        '42.某计算机字长为 8 位，其 CPU 中有一个 8 位加法器。已知无符号数 x=69，y=38，现要在该加法器中完成 x+y 的运算，则该加法器的两个输入端信息和输入的低位进位信息分别为（　　）。'
    )(answer(p`0100 0101、0010 0110、0`), p`0100 0101、0010 0110、1`, p`0100 0101、1101 1010、0`, p`0100 0101、1101 1010、1`),
    multipleChoice(
        '43.某计算机字长为 8 位，其 CPU 中有一个 8 位加法器。已知无符号数 x=69，y=38，现要在该加法器中完成 x-y 的运算，则该加法器的两个输入端信息和输入的低位进位信息分别为（　　）。'
    )(p`0100 0101、0010 0110、0`, answer(p`0100 0101、1101 1001、1`), p`0100 0101、1101 1010、0`, p`0100 0101、1101 1010、1`),
    multipleChoice(
        '44.某计算机字长为 8 位，其 CPU 中有一个 8 位加法器。已知带符号整数 x=-69，y=-38，现要在该加法器中完成 x+y 的运算，则该加法器的两个输入端信息和输入的低位进位信息分别为（　　）。'
    )(answer(p`1011 1011、1101 1010、0`), p`1011 1011、1101 1010、1`, p`1011 1011、0010 0101、0`, p`1011 1011、0010 0101、1`),
    multipleChoice(
        '45.某计算机字长为 8 位，其 CPU 中有一个 8 位加法器。已知带符号整数 x=-69，y=-38，现要在该加法器中完成 x-y 的运算，则该加法器的两个输入端信息和输入的低位进位信息分别为（　　）。'
    )(p`1011 1011、1101 1010、0`, p`1011 1011、1101 1010、1`, answer(p`1011 1011、0010 0101、1`), p`1011 1011、00100110、1`),
    multipleChoice(
        '46.某 8 位计算机中，假定 x 和 y 是两个带符号整数变量，用补码表示，x=63，y=-31，则 x+y 的机器数及其相应的溢出标志 OF 分别是（　　）。'
    )(p`1FH、0`, answer(p`20H、0`), p`1FH、1`, p`20H、1`),
    multipleChoice(
        '47.某 8 位计算机中，假定 x 和 y 是两个带符号整数变量，用补码表示，x=63，y=-31，则 x-y 的机器数及其相应的溢出标志 OF 分别是（　　）。'
    )(p`5DH、0`, answer(p`5EH、0`), p`5DH、1`, p`5EH、1`),
    multipleChoice(
        '48.某 8 位计算机中，假定带符号整数变量 x 和 y 的机器数用补码表示，[x]补=F5H，[y]补=7EH，则 x+y 的值及其相应的溢出标志 OF 分别是（　　）。'
    )(answer(p`115、0`), p`119、0`, p`115、1`, p`119、1`),
    multipleChoice(
        '49.某 8 位计算机中，假定带符号整数变量 x 和 y 的机器数用补码表示，[x]补=F5H，[y]补=7EH，则 x-y 的值及其相应的溢出标志 OF 分别是（　　）。'
    )(p`115、0`, p`119、0`, p`115、1`, answer(p`119、1`)),
    multipleChoice(
        '50.某 8 位计算机中，假定 x 和 y 是两个带符号整数变量，用补码表示，[x]补=44H，[y]补=DCH，则 x+2y 的机器数以及相应的溢出标志 OF 分别是（　　）。'
    )(p`32H、0`, p`32H、1`, answer(p`FCH、0`), p`FCH、1`),
    multipleChoice(
        '51.某 8 位计算机中，假定 x 和 y 是两个带符号整数变量，用补码表示，[x]补=44H，[y]补=DCH，则 x-2y 的机器数以及相应的溢出标志 OF 分别是（　　）。'
    )(p`68H、0`, p`68H、1`, p`8CH、0`, answer(p`8CH、1`)),
    multipleChoice(
        '52.某 8 位计算机中，假定 x 和 y 是两个带符号整数变量，用补码表示，[x]补=44H，[y]补=DCH，则 x/2+2y 的机器数以及相应的溢出标志 OF 分别是（　　）。'
    )(p`CAH、0`, p`CAH、1`, answer(p`DAH、0`), p`DAH、1`),
    multipleChoice(
        '53.假定有两个整数用 8 位补码分别表示为 r1=F5H，r2=EEH。若将运算结果存放在一个 8 位寄存器中，则下列运算中会发生溢出的是（　　）。'
    )(p`r1+r2`, p`r1-r2`, answer(p`r1×r2`), p`r1/r2`),
    multipleChoice(
        '54.对于 IEEE 754 单精度浮点加减运算，在对阶过程中，需计算两个阶码 Ex 和 Ey 之差的补码[ΔE]补。若 ΔE≥128 或 ΔE≤-129，则[ΔE]补发生溢出。假定[Ex]移、[-[Ey]移]补和[ΔE]补的最高有效位分别记为 Exs、Eys 和 Ebs，则相应的溢出判断方程为（　　）。'
    )(
        p`Overflow=Exs Eys Ebs+Exs Eys Ebs`,
        p`Overflow=Exs Eys Ebs+Exs Eys Ebs`,
        p`Overflow=Exs Eys Ebs+Exs Eys Ebs`,
        answer(p`Overflow=Exs Eys Ebs+Exs Eys Ebs`)
    ),
    multipleChoice(
        '55.IEEE 754 单精度浮点数加减运算的对阶过程中，需要计算两个阶码 Ex 和 Ey 之差的补码[ΔE]补。假设两个浮点数分别记为[x]浮和[y]浮，[Ex]移、[Ey]移和[ΔE]补的最高有效位分别记为 Exs、Eys 和 Ebs，当[ΔE]补发生溢出时，正确的处理方式是（　　）。'
    )(
        p`中止当前程序的执行，调出相应的「溢出」异常处理程序执行`,
        answer(p`当 Exs 为 1 时置最终结果为[x]浮；当 Exs 为 0 时置最终结果为[y]浮`),
        p`当 Eys 为 1 时置最终结果为[x]浮；当 Eys 为 0 时置最终结果为[y]浮`,
        p`当 Ebs 为 0 时置最终结果为[x]浮；当 Ebs 为 1 时置最终结果为[y]浮`
    ),
    multipleChoice(
        '56.若两个 float 型变量（用 IEEE 754 单精度浮点格式表示）x 和 y 的机器数分别表示为 x=40E80000H，y=C2040000H，则在计算 x+y 时，第一步对阶操作的结果[ΔE]补为（　　）。'
    )(p`0000 0111`, p`0000 0011`, p`1111 1011`, answer(p`1111 1101`)),
    multipleChoice(
        '57.对于 IEEE 754 单精度浮点数加减运算，只要对阶时得到的两个阶码之差的绝对值 |ΔE| 大于等于（　　），就无需继续进行后续处理，此时，运算结果直接取阶大的那个数。'
    )(p`24`, answer(p`25`), p`126`, p`128`),
    multipleChoice('58.IEEE 754 标准提供了以下 4 种舍入模式，其中平均误差最小的是（　　）。')(
        answer(p`就近舍入（中间值时强迫为偶数）`),
        p`正向舍入（即朝 +∞ 方向舍入）`,
        p`负向舍入（即朝-∞ 方向舍入）`,
        p`截断舍入（即朝 0 方向舍入）`
    ),
    section('部分题目的答案解析')(
        section('第 15 题')(
            p`因为-8196=-（8192+4）=-10 0000 0000 0100B，所以 si 和 usi 的机器数皆为 1101 1111 1111 1100B，作为无符号数解释时的真值为 216-1-213-2-1=65535-8192-3=57340。`
        ),
        section('第 16 题')(
            p`符号位为 1，表示 X 为负数。因为[X]原=1.x1x2x3x4，所以 X=-0.x1x2x3x4。`,
            p`要使 X>-1/2 成立，相当于-0.x1x2x3x4>-1/2 成立，必须 0.x1x2x3x4<1/2，此时，x1必须是 0，而 x2、x3、x4任意。因此，答案为 D。`
        ),
        section('第 17 题')(p`已知 X=-1011=-0001011，符号位为 1，数值部分各位取反，末位加 1，即[X]补=11110101。综上所述，答案为 C。`),
        section('第 25 题')(
            p`假定变量 i、f 的数据类型分别是 int、float。已知 i=12345，f=1.2345e3，则在一个 32 位机器中执行下列表达式时，结果为「假」的是（　　）。`,
            p`对于选项 A，因为 i=12345<16384=214，所以 i 的有效位数不会超过 15<24，因而转换为 float 型数据后，不会发生有效位数丢失，再转换为 int 型数据，与原来的值完全相同。`,
            p`对于选项 B，因为 i 的有效位数不会超过 15<53，因而转换为 double 型数据后，不会发生有效位数丢失，再转换为 int 型数据，与原来的值完全相同。`,
            p`对于选项 C，因为 f=1234.5，有小数部分，转换为 int 型数据时，小数部分被丢弃，再转换为 float 型数据后，与原来的值不相同。`,
            p`对于选项 D，因为 double 型数据的有效位数比 float 型的多，表数范围比 float 型的大，因而将 float 型数据转换为 double 型数据，其值不会发生任何变化，再转换为 float 型数据，与原来的值完全相同。`,
            p`综上所述，答案为 C。`
        ),
        section('第 26 题')(
            p`因为 IBM 370 浮点数格式的基数为 16，所以，将-265.625 先转换为十六进制表示形式。`,
            p`-265.625=-100001001.101B=-0001 0000 1001.1010B=（-0.109A）16×163。`,
            p`根据 IBM 370 的短浮点数格式，知：b0=1，b1～b7=1000000+3=1000011B，即 b0～b7=11000011B=C3H，尾数 b8～b31=109A00H。因此，-265.625 的短浮点数用十六进制表示为 C3109A00H。`
        ),
        section('第 51 题')(
            p`已知[y]补=DCH=11011100B，所以[-y]补=00100100B，[x-2y]补=[x]补+[-2y]补=[x]补+[-y]补<<1=01000100+00100100<<1=01000100+01001000=10001100=8CH，从最后一步加操作来看，是两个正数相加，结果为负数，故溢出标志 OF 为 1。综上所述，答案为 D。`
        ),
        section('第 52 题')(
            p`[x/2+2y]补=[x]补>>1+[y]补<<1=01000100>>1+11011100<<1=00100010+10111000=11011010=DAH，从最后一步加操作来看，是一个正数和一个负数相加，因此一定不会溢出。综上所述，答案为 C。`
        ),
        section('第 54 题')(
            p`对于 IEEE 754 单精度浮点加减运算，在对阶过程中，需计算两个阶码 Ex 和 Ey 之差的补码[ΔE]补，[ΔE]补=[Ex-Ey]补=[Ex]移+[-[Ey]移]补。假定[Ex]移、[-[Ey]移]补和[ΔE]补的最高有效位分别记为 Exs、Eys 和 Ebs，若 ΔE≥128，则[ΔE]补发生正溢出，此时 Ebs 为 1，而 Ex 一定为正数，即 Exs=1，Ey 一定为负数，即[Ey]移的符号位为 0，计算[-[Ey]移]补时，对[Ey]移的各位取反、末位加一，从而得到 Eys=1，综合起来的逻辑表达式就是 Exs Eys Ebs；若 ΔE≤-129，则[ΔE]补发生负溢出，此时 Ebs 为 0，而 Ex 一定为负数，即 Exs=0，Ey 一定为正数，即[Ey]移的符号位为 1，计算[-[Ey]移]补时，对[Ey]移的各位取反、末位加一，从而得到 Eys=0，综合起来的逻辑表达式就是 Exs Eys Ebs，因此，Overflow=Exs Eys Ebs+Exs Eys Ebs。`
        ),
        section('第 55 题')(
            p`假设浮点数 x 和 y 的机器数分别记为[x]浮和[y]浮，[ΔE]补=[Ex-Ey]补=[Ex]移+[-[Ey]移]补，将[Ex]移、[Ey]移和[ΔE]补的最高有效位分别记为 Exs、Eys 和 Ebs。当[ΔE]补发生溢出时，若 ΔE≥128，说明 x 的阶比 y 的阶至少大 128，y 的尾数至少要向右移 128 位，因而 y 被 x「吃掉」，结果应该取 x，此时 Exs=1；若 ΔE≤-129，说明 y 的阶比 x 的阶至少大 129，x 的尾数至少要向右移 129 位，因而 x 被 y「吃掉」，结果应该取 y，此时 Exs=0。因此，答案为 B。`
        ),
        section('第 56 题')(
            p`x 和 y 的机器数分别表示为 x=40E8 0000H=0100 0000 1…，y=C204 0000H=1100 00100…，因此，[Ex]移=1000 0001，[Ey]移=1000 0100，[ΔE]补=[Ex-Ey]补=[Ex]移+[-[Ey]移]补=1000 0001+0111 1100=1111 1101。`
        ),
        section('第 57 题')(
            p`对于 IEEE 754 单精度浮点数加减运算，若对阶时得到的两个阶码之差的绝对值 |ΔE| 等于 24，则说明阶小的那个数的尾数右移 24 位，进行尾数加减运算时，虽然其结果的前 24 位直接取阶大的那个数的相应位，但是，由于可以保留附加位，阶小的那个数右移后的尾数可能会在舍入时向前面一位进 1。例如，1.00…01×21+1.10…00×2-23=1.00…01×21+0.00…0011×21=1.00…0111×21。其中，加粗的两位为保留的附加位，最终需要根据这两位进行舍入，显然，舍入后的结果为 1.00…10×21，并不等于阶大的那个数。若 |ΔE| 等于 25，则保留的附加位中，最左边第 1 位一定是 0，采用就近舍入时，这些附加位完全被丢弃。因此，|ΔE| 大于等于 25 时，可以使运算结果直接取阶大的那个数。`
        )
    )
).elem
