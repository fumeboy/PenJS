import { p, section } from '@src/components/@write'
const title = '3.3　基本术语解释'
const page = section(title)(
    section('反汇编程序（disassembler）')(p`反汇编程序是一种语言转换程序，它的功能和汇编程序相反，能把机器语言程序转换为汇编语言程序。`),
    section('机器级代码（machine-level code）')(p`机器语言程序和汇编语言程序与具体机器的指令集体系结构相关，因而将它们统称为机器级代码。`),
    section('指令（instruction）')(p`指令是计算机硬件能够识别并直接执行的操作命令。用二进制序列表示，由操作码和操作数或操作数的地址码等字段组成。`),
    section('指令系统（instruction set）')(p`指令系统也称为指令集，是计算机中所有指令的集合。`),
    section('指令集体系结构（Instruction Set Architecture，ISA）')(
        p`指令集体系结构是计算机硬件与系统软件之间的接口，其核心部分是指令集，同时还包含数据类型和数据格式定义、寄存器设计、I/O 空间的编址和数据传输方式、中断结构、计算机状态的定义和切换、存储保护等。`
    ),
    section('指令字长（instruction length）')(p`指令字长是指一条指令的二进制代码位数。有定长指令字格式和变长指令字格式两种不同的指令系统。`),
    section('定长指令（fixed length instruction）')(p`定长指令是指机器中所有指令的位数是相同的，目前定长指令大多是 32 位指令字。`),
    section('变长指令（variable length instruction）')(p`变长指令是指机器中的指令有长有短，但每条指令的长度一般都是 8 的倍数。`),
    section('操作码（operate code）')(
        p`操作码是指令中用于指出操作性质的字段，一般分为定长操作码和扩展操作码。定长操作码是指机器中所有指令的操作码字段位数相同；扩展操作码是指机器中指令的操作码字段位数不都相同，也称为不定长操作码。`
    ),
    section('地址码（address code）')(
        p`地址码是指令中用于指出操作数地址的字段。一条指令中一般有多个地址码字段。地址码字段的个数与许多因素有关。一个地址码字段可能是一个立即数，可能是操作数所在的存储单元地址，可能是一个间接的存储单元地址的地址，可能是寄存器编号，可能是 I/O 端口号，可能是一个形式地址等。`
    ),
    section('大端序（big endian ordering）')(
        p`大端序是指操作数在内存存放时，指令中给出的地址是操作数最高有效字节（MSB）所在的地址。例如，假设一个 32 位数据「12345678H」的地址为 100，则 12H、34H、56H 和 78H 分别存放在第 100、101、102 和 103 号单元中。IBM S/370、Motorola 680x0 等是大端序机器。`
    ),
    section('小端序（little endian ordering）')(
        p`小端序是指操作数在内存存放时，指令中给出的地址是操作数最低有效字节（LSB）所在的地址。例如，假设一个 32 位数据「12345678H」的地址为 100，则 12H、34H、56H 和 78H 分别存放在第 103、102、101 和 100 号单元中。Intel 80x86 等是小端序机器。`
    ),
    section('字地址（word address）')(
        p`每个内存单元都有一个地址，假定机器中一个字为 32 位，按字节编址，那么字地址就是指具有 4 的倍数的那些地址（如 0、4、8、12、…），对应的还有半字地址（2 的倍数，如 0、2、4、6、…）、双字地址（8 的倍数，如 0、8、16、…）等。`
    ),
    section('边界对齐（boundary alignment）')(
        p`有些机器在操作数存放到内存单元时，要求按照相应的地址边界进行对齐。例如，假定机器中一个字为 32 位，按字节编址，那么一个 32 位的数据（如一个 float 型的变量或 32 位的 int 型整数变量等）就必须存放在字地址上，一个 16 位的数（如 16 位 short 型的短整数等）就必须放在半字地址上，而 8 位的数据（如 char 型字符）就可以放在任何边界地址上而不需对齐。`
    ),
    section('累加器（accumulator）')(
        p`在中央处理器 CPU 中，累加器（accumulator，简称 ACC）是一种暂存器，用来储存计算所产生的中间结果。早期机器中没有通用寄存器组，只有一个累加器，在这种情况下，如果没有像累加器这样的暂存器，那么在每次计算后就必须要把结果写回到内存，然后可能还要再读回来。这样就会增加访问内存的次数，降低程序运行的效率。利用累加器进行中间结果存储的一个典型例子就是把一组数字加起来：一开始累加器设定为零，每个数字依序被加到累加器中，当所有数字都被加入后，结果才写回到主内存中。`
    ),
    section('程序计数器（Program Counter，PC）')(
        p`程序计数器又称为指令计数器或指令指针 IP，是一个特殊的地址寄存器，专门用来存放下一条要执行指令的地址。因为它本身是个寄存器，所以也称为指令指针寄存器或指令地址寄存器。通常程序是顺序执行的，程序的指令序列在内存中一般也是按连续地址存放的。在开始运行程序之前，总是将第一条指令的地址放入 PC；每取出一条指令并执行后，控制器就使 PC 的内容自动增量（加上当前指令的长度），指明下一条要执行的指令所存放的存储单元地址，从而可以控制指令的顺序执行；在遇到需要改变程序执行顺序的情况时，一般由转移类指令将转移目标地址送往程序计数器，从而实现程序的转移。`
    ),
    section('指令寄存器（Instruction Register，IR）')(
        p`指令寄存器用来保存当前正在执行的一条指令。当执行一条指令时，先从存储器取出指令，然后送至指令寄存器。指令寄存器中的操作码部分被送到指令译码器（Instruction Decoder，ID），经 ID 译码识别这条指令的功能后，送出具体的操作控制信号。`
    ),
    section('程序状态字（Program Status Word，PSW）')(
        p`程序状态字是表示程序运行状态的一个二进制位序列，一般包含一些反映指令执行结果的标志信息（如进位标志、溢出标志、符号标志等）和设定的一些状态信息（如中断允许/禁止状态、管理程序/用户程序状态等）。`
    ),
    section('程序状态字寄存器（Program Status Word Register，PSWR）')(p`程序状态字寄存器是用来存放程序状态字的寄存器。`),
    section('标志寄存器（Flag Register）')(p`标志寄存器是 80x86 体系结构中用来表示程序状态和标志的寄存器，如 FLAGS、EFLAGS。`),
    section('栈（stack）')(
        p`栈是一块特殊的存储区，采用「先进后出」的方式进行访问，主要用来在程序切换（如过程调用）时保存各种信息。栈底固定不动，栈顶浮动，用一个专门的寄存器（SP）来作为栈顶指针。从栈生长的方向来分，有「自顶向下」和「自底向上」两种。从栈的位置来分，有硬栈和软栈。硬栈的栈区由寄存器实现，软栈的栈区由内存实现。`
    ),
    section('栈指针（Stack Pointer，SP）')(
        p`SP 是一个特殊的地址寄存器，用来存放栈的栈顶指针。如果是硬栈，则栈顶指针是栈顶寄存器的编号；如果是软栈，则栈顶指针是栈顶所指向的存储单元的地址。`
    ),
    section('双目运算（two-operand operate）')(p`双目运算是指需要两个操作数才能进行的运算。如加、减、乘、除、与、或等算术或逻辑运算都是双目运算。`),
    section('单目运算（one-operand operate）')(p`单目运算是指只需要一个操作数就能进行的运算。如取负、取反等算术或逻辑运算都是单目运算。`),
    section('寻址方式（addressing mode）')(
        p`在程序执行过程中，需要取指令和操作数，确定指令和操作数的存放位置的方式称为寻址方式。确定指令存放位置的过程称为指令寻址，确定操作数存放位置的过程称为数据寻址。`
    ),
    section('有效地址（effective address）')(
        p`有效地址是指存储器操作数所在存储单元的地址。若不采用虚拟存储机制，则有效地址是主存地址；若采用虚拟存储机制，则有效地址是虚拟地址。`
    ),
    section('立即寻址（immediate addressing）')(p`指令中的地址码直接给出操作数本身，这称为立即寻址。`),
    section('直接寻址（direct addressing）')(p`指令中的地址码给出的是操作数所在的存储单元地址，这称为直接地址。`),
    section('间接寻址（indirect addressing）')(p`指令中的地址码给出的是操作数所在的存储单元地址，这称为间接地址。`),
    section('寄存器寻址（register addressing）')(p`指令中的地址码给出的是操作数所在的寄存器的编号，这称为寄存器寻址。`),
    section('寄存器间接寻址（register indirect addressing）')(
        p`指令中的地址码给出的是操作数所在的存储单元的地址所存放的寄存器的编号，这称为寄存器间接寻址。`
    ),
    section('偏移寻址（displacement addressing）')(
        p`指令通过某种方式给出一个形式地址和一个基地址（往往在某个寄存器中），经过相应的计算（基地址加形式地址）得到操作数所在的存储单元地址，这称为偏移寻址。具体的偏移寻址方式有：变址寻址、相对寻址和基址寻址。`
    ),
    section('变址寄存器（index register）')(p`变址寄存器是一个特殊的地址寄存器，用来存放变址寻址方式下的变址值，通常是数组元素的下标值等。`),
    section('变址寻址（indexing addressing）')(
        p`在变址寻址方式下，指令中的地址码给出一个形式地址，并且隐含或明显地指定一个寄存器作为变址寄存器，变址寄存器的内容（变址值）和形式地址相加，得到操作数的有效地址，根据有效地址到存储器中访问，去取操作数或写运算结果。`
    ),
    section('比例变址（scale-indexing）')(
        p`比例变址是 IA-32 中的一种变址寻址方式，在比例变址方式下，变址值通过变址寄存器的内容与一个比例因子相乘得到，通常用于数组元素的访问，此时，变址寄存器中存放的是数组元素的下标，比例因子为数组元素的大小，例如，对于 short 型数组，每个数组元素为 16 位，即两个字节，因此比例因子为 2。`
    ),
    section('相对寻址（relative addressing）')(
        p`在相对寻址方式下，指令中的形式地址给出一个位移量 D，而基准地址由程序计数器 PC 提供，即有效地址 EA=（PC）+D。位移量可正可负，也就是说，要找的可以是当前指令前 D 个单元处的信息，也可以是当前指令后 D 个单元处的信息。`
    ),
    section('基址寻址（base addressing）')(
        p`在基址寻址方式下，指令中的地址码给出一个形式地址作为位移量，并且隐含或明显地指定一个寄存器作为基址寄存器，基址寄存器的内容和形式地址相加，得到操作数的有效地址，根据有效地址到存储器中访问，去取操作数或写运算结果。`
    ),
    section('基址寄存器（base register）')(
        p`基址寄存器是一个特殊的地址寄存器，用来存放基址寻址方式下的基准地址，通常是一个用户程序的首地址，或一块存储区的首地址。`
    ),
    section('栈寻址（stack addressing）')(
        p`栈寻址方式下，操作数被指定在栈中。栈寻址总是从栈顶取操作数，运算后的结果自动放到栈顶。栈顶的位置由一个专门的栈指针 SP 来指示。所以，指令中不需要给出操作数地址，是一种零地址指令。与栈有关的操作有入栈（PUSH）、出栈（POP）和运算类操作。`
    ),
    section('通用寄存器（General Purpose Register，GPR）')(
        p`一般把用户可访问寄存器称为通用寄存器。这些寄存器都有一个编号，在指令中用编号标识寄存器。执行指令时，指令中的寄存器编号要送到一个地址译码器进行译码，然后才能选中某个寄存器进行读写。通用寄存器可以用来存放操作数或运算结果，或作为地址指针寄存器、变址寄存器、基址寄存器等。有的处理器架构把 PC 也作为一个通用寄存器使用。`
    ),
    section('R-R 型指令（Register-Register type instruction）')(p`R-R 型指令是指两个操作数都在寄存器中的指令。`),
    section('R-S 型指令（Register-Storage type instruction）')(p`R-S 型指令是指一个操作数在寄存器中，另一个操作数在主存单元中的指令。`),
    section('S-S 型指令（Storage-Storage type instruction）')(p`S-S 型指令是指两个操作数都在主存单元中的指令。`),
    section('数据传送指令（data transfer instruction）')(p`数据传送指令是指将数据在寄存器和寄存器之间、存储单元和寄存器之间进行传送的指令。`),
    section('取数指令（load）')(p`取数指令特指将数据从存储单元取到寄存器的指令。`),
    section('存数指令（store）')(p`存数指令特指将数据从寄存器保存到存储单元的指令。`),
    section('相对转移（relative jump）')(p`相对转移是指转移目标地址通过 PC 的值加上一个偏移量形成。所以，转移到的目的地和当前指令的位置有关。`),
    section('绝对转移（absolute jump）')(p`绝对转移是指转移目标地址由指令指定的一个绝对地址确定，而与当前指令的位置没有关系。`),
    section('条件转移（conditional jump，branch）')(
        p`条件转移是一种分支指令，也称为条件分支。根据前面指令或当前指令执行的结果确定是跳转到转移目标地址处执行，还是顺序执行。`
    ),
    section('无条件转移（unconditional jump）')(p`无条件转移是一种直接跳转指令，执行完当前指令后，无条件地跳转到目标转移地址处执行。`),
    section('过程（procedure）')(
        p`构造过程或子程序是程序员进行模块化程序设计的一种手段，通常程序员把一个大的任务分解成一些子任务，每个子任务用一个过程来实现，这样做一方面使得程序容易理解，另一方面也使过程可以被多个程序使用，即可重用代码。`
    ),
    section('过程调用（procedure call）')(
        p`一个过程调用包括将数据（以过程参数和返回值的形式出现）和控制从一个过程传递到另一个过程。此外，在进入被调用过程后，必须为被调用过程的局部变量分配空间，并在退出过程时释放这些空间。`
    ),
    section('调用指令（call instruction）')(
        p`调用指令是用于将控制从调用过程转移到被调用过程的指令。如 x86 体系结构中的 call 指令。使用这类调用指令时，需要给出被调用过程的首地址。其操作过程为：保存返回地址到特定寄存器或栈顶，然后跳转到被调用过程。`
    ),
    section('返回地址（return address）')(p`返回地址是调用指令后面一条指令的地址，也即被调用过程执行完后必须返回的返回点处的地址。`),
    section('返回指令（return instruction）')(
        p`返回指令是用于从被调用过程控制转回到调用过程的指令。该指令从某个特定的寄存器或栈顶取得返回地址，并按返回地址进行跳转。`
    ),
    section('调用过程（caller）')(p`在过程调用中，通过过程调用指令调用一个过程或子程序的过程。有时也称为主程序。`),
    section('被调用过程（callee）')(
        p`被调用过程是指用过程调用指令所调用的过程或子程序。被调用过程最后必须用返回指令返回到调用过程中调用指令后面的那条指令继续执行。`
    ),
    section('叶过程（leaf procedure）')(p`叶过程是指不调用其他过程的过程。`),
    section('栈帧（stack frame）')(
        p`大多数机器只提供简单的过程调用指令和返回指令。一个过程调用中的参数传递、被调用过程中局部变量的分配和释放等还需要另外的机制来实现。以上操作主要通过栈（stack）来实现，栈用来传递过程参数、存储返回信息、保存寄存器的内容和过程局部变量等。为单个过程分配的那部分栈区称为栈帧，也称为过程帧（procedure frame）。`
    ),
    section('帧指针 fp（frame pointer）')(
        p`在程序运行过程中，可能会有多个过程嵌套调用，每个未返回的过程都有一个栈帧，当前正在执行的过程的栈帧称为当前帧。它由两个指针定界：一个是指示当前帧底部的帧指针 fp（IA-32 中用 EBP 来指示），另一个是指示当前帧顶部的栈指针 sp。`
    ),
    section('源程序文件（source program file）')(p`指用某种高级语言书写的源程序文件，如 C 语言源程序文件*.c 等。`),
    section('汇编语言程序文件（assemble language source file）')(
        p`汇编语言程序文件是指用某种汇编语言书写的源程序文件，如 UNIX 系统中的汇编语言源程序文件*.s、MS-Windows 中的*.asm 文件等。`
    ),
    section('可重定位目标文件（relocatable object file）')(
        p`编译程序和汇编程序对源程序进行翻译处理所得到的机器语言程序称为目标程序文件，是由机器指令组成的二进制代码，如 UNIX 系统中的*.o 文件、MS-Windows 系统中的*.obj 文件等。一般而言，目标程序文件中包含目标文件头、文本段（机器代码）、数据段、重定位信息、符号表、调试信息等。因为目标文件是可重定位的，所以也称为可重定位目标文件。`
    ),
    section('可执行目标文件（executable object file）')(
        p`可执行目标文件是通过装入程序能被直接装入存储器执行的二进制代码文件，通常与可重定位目标文件有着相同的格式。可执行目标文件中的模块可以调用其他动态链接库中的函数。可执行目标文件有时简称为可执行文件。`
    ),
    section('链接程序（linker/link editor）')(
        p`链接程序是把编译或汇编好的多个可重定位目标文件和一些库函数目标文件链接生成一个可执行目标文件的工具软件。`
    ),
    section('装入程序（loader）')(
        p`装入程序也称为加载器或加载程序，是用于将可执行目标文件装入系统并启动执行的软件模块。一般来说，可执行文件的装入是由操作系统内核来实现的，因此装入程序属于操作系统的一部分。`
    ),
    section('伪指令（pseudo instruction）')(
        p`伪指令是指在汇编语言程序中使用的但并不存在的「假」指令。假定在汇编语言程序中需要经常使用某个基本功能，但是该功能并不能用单条机器指令来实现，而是需要用多条指令来实现，此时一般用一条简洁自然的伪指令来表示多条机器指令——它们在功能上等价。汇编程序在对汇编语言源程序进行汇编时，将伪指令转换为等价的机器指令序列。`
    ),
    section('复杂指令集计算机（Complex Instruction Set Computer，CISC）')(
        p`早期的计算机为了增加功能和更好地支持高级语言而不断地增加新的指令类型，使 CPU 可以直接实现复杂的指令操作。由于这种指令系统中的指令功能复杂、寻址方式多、指令长度可变、指令格式多样，因此采用这种指令系统的计算机被称为复杂指令集计算机。`
    ),
    section('精简指令集计算机（Reduced Instruction Set Computer，RISC）')(
        p`这种计算机采用简化的指令系统，指令集中只包含程序中常用的指令，只有 load 和 store 指令才能访存，运算类指令只能是 R-R 型，提供大量通用寄存器以减少访存次数，采用流水线方式执行指令，控制器用硬连阵列逻辑实现，并采用优化的编译技术。`
    )
).elem
