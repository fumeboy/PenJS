import { p, section } from '@src/components/@write'
const title = '3.2　主要内容提要'
const page = section(title)(
    section(`程序转换概述`)(
        p`计算机硬件只能识别和理解机器语言程序，用各种汇编语言或高级语言编写的源程序都要翻译（汇编、解释或编译）成以机器指令形式表示的机器语言才能在计算机上执行。通常对于编译执行的程序来说，都是先将高级语言源程序通过编译器转换为汇编语言目标程序，然后将汇编语言源程序通过汇编程序转换为机器语言目标程序。机器语言就是由 0/1 组成的机器指令序列，因而机器语言与指令集体系结构密切相关，本书主要以 IA-32 为模型机进行讲解。程序转换过程涉及编译、汇编、链接等一系列过程，此外，在转换过程中还可能需要进行程序调试，因而还需要有反汇编、跟踪调试等软件工具的支撑。`
    ),
    section(`IA-32 指令系统概述`)(
        p`Intel 把 32 位 x86 架构的名 x86-32 改为 IA-32，全名为「Intel Architecture，32-bit」。高级语言中的表达式最终通过指令指定的运算来实现，表达式中出现的变量或常数就是指令中指定的操作数，因而高级语言所支持的数据类型与指令中指定的操作数类型之间有密切的关系。IA-32 提供了对应高级语言中各类变量或常数的数据类型，包括 8 位、16 位和 32 位无符号整数，8 位、16 位和 32 位带符号整数，以及 IEEE 754 单精度和双精度浮点数。IA-32 指令中的操作数有三类：立即数、寄存器操作数和存储器操作数，寄存器操作数存放在 8 个 8/16/32 位通用寄存器中，ESP 和 EBP 寄存器分别是栈指针寄存器和基址指针寄存器。指令指针寄存器 EIP 和标志寄存器 EFLAGS 是两个专用寄存器，前者用于存放将要执行的指令的地址，后者存放机器的状态和标志信息。IA-32 支持实地址模式和保护模式，在保护模式下，处理器采用段页式虚拟存储器管理方式，CPU 首先通过分段方式得到线性地址 LA，再通过分页方式实现从线性地址到物理地址的转换。保护方式下，存储器操作数的寻址方式中，有位移、基址、基址 + 位移、比例变址 + 位移、基址 + 变址 + 位移、基址 + 比例变址 + 位移等多种方式。`
    ),
    section(`IA-32 常用指令类型`)(
        p`与大多数 ISA 一样，IA-32 提供了数据传送、定点算术运算、逻辑运算、移位和程序流程控制等常用指令类型。传送指令用于寄存器、存储单元或 I/O 端口之间传送信息，分为通用数据传送、地址传送、标志传送和 I/O 信息传送等几类，除了部分标志传送指令外，其他指令均不影响标志位的状态。定点算术运算指令用于二进制数和无符号十进制数的各种算术运算。IA-32 中的二进制定点数可以是 8 位、16 位或 32 位数，除了除法指令外的定点运算指令都会生成相应的标志信息。常用逻辑运算指令（包括 TEST 指令）中，仅 NOT 指令不影响条件标志位，其他指令执行后，OF=CF=0，ZF 和 SF 则根据运算结果来设置：若结果为全 0，则 ZF=1；若最高位为 1，则 SF=1。移位指令将寄存器或存储单元中的 8 位、16 位或 32 位二进制数进行算术移位、逻辑移位或循环移位。在移位过程中，把 CF 看作扩展位，用它接收从操作数最左或最右移出的一个二进制位。只能移动 1～31 位，所移位数可以是立即数或存放在 CL 寄存器中的一个数值。IA-32 提供了多种控制转移指令，有无条件转移指令、条件转移指令、条件设置指令、调用/返回指令和中断指令等。这些指令中，除中断指令外，其他指令都不影响状态标志位，但有些指令的执行受状态标志的影响。与条件转移指令和条件设置指令相关的还有条件传送指令。`
    ),
    section(`x87 浮点处理指令和 MMX/SSE 指令`)(
        p`IA-32 的浮点处理架构有两种：较早的一种是与 x86 配套的浮点协处理器 x87 架构，采用栈结构；另一种是由 MMX 发展而来的 SSE 指令集架构，采用的是单指令多数据（Single Instruction Multi Data，SIMD）技术，包括 SSE、SSE2、SSE3、SSSE3、SSE4 等。对于 IA-32 架构，GCC 编译器默认生成 x87 指令集代码，如果想要生成 SSE 指令集代码，则需要设置适当的编译选项。`
    ),
    section(`过程调用的机器级表示`)(
        p`引入过程使得每个程序员只需要关注本模块中函数或过程的编写任务。调用过程只要传送输入参数给被调用过程，最后再由被调用过程返回结果参数给调用过程。将整个程序分成若干模块后，编译器对每个模块可以分别编译。为了彼此统一，并能配合操作系统工作，编译的模块代码之间必须遵循一些调用接口约定，这些约定由编译器强制执行，汇编语言程序员也必须强制按照这些约定执行，包括寄存器的使用约定、栈帧的建立和参数传递约定等。IA-32 的调用指令 CALL 和返回指令 RET 是用于过程调用的主要指令，寄存器 EBP 和 ESP 分别是帧指针寄存器和栈指针寄存器，分别用来指向当前栈帧的底部和顶部。`
    ),
    section(`选择语句和循环语句的机器级表示`)(
        p`C 语言主要通过选择结构（条件分支）和循环结构语句来控制程序中语句的执行顺序。流程控制语句有 9 种，分成三类：选择语句、循环语句和辅助控制语句。选择语句有 if～（then）语句、if～（then）～else 语句和 switch～case 语句；循环语句有 do～while 语句、for 语句和 while 语句。辅助控制语句有 break、continue、goto 和 return 语句。编译器可以使用在底层 ISA 中提供的各种条件标志设置功能、条件转移指令、条件设置指令、条件传送指令、无条件转移指令等相应的机器级程序支持机制来实现这类语句。`
    ),
    section(`复杂数据类型的分配和访问`)(
        p`机器级代码中，基本类型对应的数据通常通过单条指令就可以访问和处理，这些数据在指令中或者是以立即数的方式出现，或者是以寄存器数据的形式出现，或者是以存储器数据的形式出现。而对于构造类型的数据，由于其包含多个基本类型数据，因此不能直接用单条指令来访问和运算，通常需要特定的代码结构和寻址方式对其进行处理。典型的构造类型数据包括数组（array）、指针数组、结构（struct）和联合（union）等。编译器在对构造型复杂数据类型中的数据进行存储分配时，需要了解系统关于对齐方式的约定。`
    ),
    section(`越界访问和缓冲区溢出及其攻击防范`)(
        p`C 语言中的数组元素可以使用指针来访问，因而对数组的引用没有边界约束，也即程序中对数组的访问可能会有意或无意地超越数组存储区范围而无法发现。可以把这种数组存储区看作一个缓冲区，这种超越数组存储区范围的访问称为缓冲区溢出。缓冲区溢出是一种非常普遍、非常危险的漏洞，在各种操作系统、应用软件中广泛存在。缓冲区溢出攻击是利用缓冲区溢出漏洞所进行的攻击行为。缓冲区溢出攻击可以导致程序运行失败、系统关机、重新启动等后果。如果有人恶意利用在栈中分配的缓冲区的写溢出，悄悄地将一个恶意代码段的首地址作为「返回地址」覆盖地写到原先正确的返回地址处，那么，程序就会在执行 ret 指令时悄悄地转到这个恶意代码段执行，从而可以轻易取得系统特权，进而进行各种非法操作。`
    ),
    section(`兼容 IA-32 的 64 位系统简介`)(
        p`对于编译器来说，对高级语言程序进行编译可以有两种选择：一种是按 IA-32 指令集将目标编译成 IA-32 代码，另一种是按 x86-64 指令集将目标编译成 x86-64 代码。通常，在 IA-32 架构上运行的是 32 位操作系统，GCC 默认生成 IA-32 代码；在 x86-64 架构上运行的是 64 位操作系统，GCC 默认生成 x86-64 代码。Linux 和 GCC 将前者称为「i386」平台，将后者称为「x86-64」平台。`,
        p`与 IA-32 代码相比，x86-64 具有更多的通用寄存器个数；具有更长的通用寄存器位数，从 32 位扩展到 64 位；字长从 32 位变为 64 位，因而逻辑地址从 32 位变为 64 位；对于 long double 型数据，虽然还是采用与 IA-32 相同的 80 位扩展精度格式，但是，所分配的存储空间从 IA-32 的 12 字节大小扩展为 16 字节大小；过程调用时，对于入口参数只有 6 个以内的整型变量和指针型变量的情况，通常用通用寄存器而不是栈来传递，这样使得大多数情况下执行时间比 IA-32 代码更短；128 位的 MMX 寄存器从原来的 8 个增加到了 16 个，浮点操作采用基于 SSE 的面向 XMM 寄存器的指令集，而不采用基于浮点寄存器栈的指令集。`
    )
).elem
