import { p, section } from '@src/components/@write'
const title = '3.4　常见问题解答'
const page = section(title)(
    section('1.一台计算机中的所有指令都是一样长吗？')(
        p`答：不一定。有定长指令字和不定长指令字两种指令格式。定长指令字格式机器的所有指令都一样长，称为规整型指令，目前定长指令字大多是 32 位指令字。不定长指令字格式机器的指令有长有短，但每条指令的长度一般都是 8 的倍数。所以，一个指令字在存储器中存放时，可能占用多个存储单元；从存储器读出并通过总线传输时，可能分多次进行，也可能一次读多条指令。IA-32 是一种典型的变长指令字体系结构。`
    ),
    section('2.每一条指令中都包含操作码吗？')(p`答：是的。每一条指令都必须告诉 CPU 该指令做什么操作，所以必须指定操作码。`),
    section('3.每条指令中的地址码个数都一样吗？')(
        p`答：不一定，有的没有地址码，有的包含一个地址码，有的是两个或三个。地址码个数不一样的主要原因有三个：① 每条指令操作数的个数可能不同。有的指令是双目运算指令，涉及两个源操作数和目的操作数；有的是单目运算，只涉及一个源操作数和目的操作数；还有的指令只是控制操作，不涉及操作数，如停机、复位、空操作等指令。所以每条指令涉及的操作数个数不同。② 每个操作数的寻址方式可能不同。不同的寻址方式给出的地址码个数也不同。③ 地址码的默认方式可能不同。有的操作数或地址码用的是隐含指定方式，在指令中不明显给出，如累加器、栈顶等。综上所述，每条指令中的地址码个数可能相差很大。`
    ),
    section('4.一条指令中的所有操作数都采用相同的寻址方式吗？')(
        p`答：不一定。对于规整型指令集，一般一条指令只包含一种寻址方式，这样在指令操作码中就隐含了寻址方式，不需要专门有寻址方式字段。但是，对于不规整型指令集，一条指令中的若干操作数可能存放在不同地方，因而每个操作数可能有各自的寻址方式。`
    ),
    section('5.指令中要明显给出下一条指令的地址吗？')(
        p`答：不需要。指令在主存中按执行顺序连续存放。在大多数情况下，指令被顺序执行，只有遇到转移指令（如无条件转移、条件分支、调用和返回等指令）才改变指令执行的顺序。所以，可以用一个专门的计数寄存器来存放下一条要执行的指令地址，而不需要在指令中专门给出下一条指令的地址。这个计数器称为程序计数器 PC 或指令指针 IP。`,
        p`当顺序执行时，CPU 直接通过对 PC 加「1」来使 PC 指向下一条顺序执行的指令，这里的「1」是指一条指令的长度，即当前指令所占的存储单元数；当执行到转移指令时，根据指令执行的结果进行相应的地址运算，把运算得到的转移目标地址送到 PC 中，使得执行的下一条指令为需要转移到的目标指令。`
    ),
    section('6.一个操作数在内存中可能占多个单元，怎样在指令中给出操作数的地址呢？')(),
    section(
        '答：现代计算机大多采用字节编址方式，即一个存储单元只能存放一个字节的信息。一个操作数（如 char 型、int 型、float 型、double 型）可能是 8 位、16 位、32 位或 64 位等，因此可能占用 1 个、2 个、4 个或 8 个存储单元。也就是说，一个操作数可能有多个存储地址对应，在指令中给出哪个地址呢？'
    )(
        p`有两种不同的地址指定方式：大端方式和小端方式。在大端方式下，指令中给出的地址是操作数最高有效字节（MSB）所在的地址。在小端方式下，指令中给出的地址是操作数最低有效字节（LSB）所在的地址。`
    ),
    section('7.地址码位数与地址空间大小和编址单位的关系是什么？')(
        p`答：指令中的地址码如果是存储单元地址，那么地址码位数与地址空间大小和编址单位的长度有关。编址单位的长度就是存储单元的宽度，也就是最小的寻址单位。存储器可以按字节编址（8 位），也可以按字编址（如 16 位、32 位等）。地址空间大小和编址单位确定后，地址码位数就被确定了。例如，若地址空间大小为 4GB，编址单位是字节，则存储单元地址就是 32 位（因为 4GB=232B）；若按字（假定一个字为 32 位）编址，则存储单元地址就是 30 位（因为 4GB=232B=230×4B）。`
    ),
    section('8.累加器型指令有什么特点？')(
        p`答：累加器型指令的一个源操作数和目的操作数总是在累加器中，是隐含指定的，所以指令中不需要给出累加器的编号。因而，累加器型指令的指令字相对来说较短，但由于每次运算结果都只能放到累加器中，可能会增加一些将累加器数据存入存储单元的指令，而使程序所含指令数增加。`
    ),
    section('9.栈型指令有什么特点？')(
        p`答：与栈有关的操作有入栈（PUSH）、出栈（POP）和运算类操作。运算类指令分单目运算和双目运算，总是从栈顶取操作数，运算后的结果自动放到栈顶。所以，指令中不需要给出操作数地址，因此，栈型指令的指令字较短。但因为所有操作数都只能在栈顶，所以完成同样一个程序的操作步骤会增加，使得程序所含指令数增加。`,
        p`栈指令的访存次数取决于采用的是软栈还是硬栈。如果是软栈（栈区由内存实现），对于双目运算，需要访问 4 次内存：取指、取源数 1、取源数 2、存结果。如果是硬栈（栈区由寄存器实现），则只需取指令时访问一次内存。`
    ),
    section('10.通用寄存器型指令有什么特点？')(
        p`答：通用寄存器型指令是相对于累加器型指令和栈型指令而言的，指令中的操作数和运算的结果既不是隐含在累加器中，也不是隐含在栈中，而是在 CPU 中提供了多个通用寄存器，操作数和结果可以放在这些寄存器中，指令必须明显地指出操作数和结果在哪个寄存器或哪个存储单元中，要给出寄存器的编号或存储单元地址。目前大多数指令系统采用通用寄存器型指令风格。`
    ),
    section('11.装入/存储型指令有什么特点？')(
        p`答：装入/存储型指令是用在规整型指令系统中的一种通用寄存器型指令风格。为了规整指令格式，使指令具有相同的长度，规定只有装入指令（Load）和存储指令（Store）才能访存，而运算指令不能直接访存，只能从寄存器取数进行运算，运算的结果也只能送到寄存器。因为寄存器编号较短，而存储单元地址位数较长，所以通过某种方式可以使运算指令和访存指令的长度一致。`,
        p`这种装入/存储型风格的指令系统最大的特点是指令格式规整，指令长度一致，一般为 32 位。由于只有 Load/Store 指令才能访问内存，程序中可能会包含许多装入指令和存储指令，而且与一般的通用寄存器型指令风格相比，其程序中包含的指令数会更多。`
    ),
    section('12.指令寻址方式和数据寻址方式有什么不同？')(
        p`答：在程序执行过程中，需要取指令和操作数，确定指令存放位置的过程称为指令寻址方式，确定操作数存放位置的过程称为数据寻址方式。指令寻址和数据寻址的复杂度是不一样的。`,
        p`指令寻址：指令基本上按执行顺序存放在存储器中，执行过程中，指令总是从存储单元被取到指令寄存器 IR 中。顺序执行时，用指令计数器 PC+「1」来得到下一条指令的地址；跳转执行时，通过转移指令的寻址方式，计算出转移目标地址，然后送到 PC 中。转移目标地址的形成方式主要有三种：立即寻址（直接地址）、相对寻址（相对地址）和间接寻址（间接地址）。`,
        p`数据寻址：开始时，数据被存放在存储器中，在指令执行过程中，存储器中的数据可能被装入 CPU 的寄存器中，寄存器数据可能被存储到存储器中或者特定的栈区；还有的操作数可能是 I/O 端口中的内容，或本身就包含在指令中（即立即数）。另外，运行的结果也可能要被送到 CPU 的寄存器、栈、I/O 端口或存储单元中，所以，数据的寻址要涉及对寄存器、存储单元、栈、I/O 端口、立即数等的访问。此外，操作数可能是某个数组的元素，或者是结构（struct）或联合（union）类型数据中的成员分量。综上所述，数据的寻址比指令的寻址要复杂得多。`
    ),
    section('13.如何指定指令的寻址方式？')(
        p`答：CPU 根据指令约定的寻址方式对地址码的有关信息进行解释，以找到下条要执行的指令或指令所需的操作数。有的指令设置专门的寻址方式字段，显式说明采用何种寻址方式；有的指令通过操作码隐含寻址方式。`,
        p`规整型指令系统一般在一条指令中只包含一种寻址方式，这样就可在指令操作码中隐含寻址方式，不需要专门有寻址方式字段。但是，对于不规整型指令系统，一条指令中的若干操作数可能存放在不同的地方，因而每个操作数可能有各自的寻址方式字段。`
    ),
    section('14.指令的操作数可能存放在机器的哪些地方？')(
        p`答：指令的操作数可能存放在内存单元、寄存器、栈和 I/O 端口中，或者直接存在于指令本身中。① 操作数在存储单元中。指令必须以某种方式给出存储单元的地址。又可分为以下几种情况：对单个独立的操作数进行处理；对一个数组中的若干个连续元素或一个数组元素进行处理；对一个表格或表格中的某个元素进行处理，等等。这些不同的情况需要提供不同的寻址方式进行操作数的访问。② 操作数在寄存器中。指令中只要直接给出寄存器的编号即可。③ 操作数在栈中。若有专门的栈指令，则指令中不需要给出操作数的地址，数据的地址隐含地由栈指针给出。④ 操作数在 I/O 端口中。当某个 I/O 接口中的寄存器内容要和 CPU 中的寄存器内容交换时，要用 I/O 指令，在 I/O 传送指令中，需提供 I/O 端口号。⑤ 操作数是指令中的立即数。此时，操作数是指令的一部分，直接从指令中的立即数字段取操作数。`
    ),
    section('15.有哪些常用的数据寻址方式？')(
        p`答：数据寻址方式可以归为以下几类。① 立即寻址。指令中的立即数字段既可以作为操作数，也可以作为直接转移地址。取到 ALU 运算前，可能要对其进行扩展。② 直接寻址类。指令中直接给出操作数所在的寄存器编号、I/O 端口号或存储单元地址，如直接寻址方式、寄存器寻址方式。③ 间接寻址类。操作数在存储单元中，而操作数的地址存放在寄存器或另一个存储单元中，指令中给出操作数的地址所在的寄存器编号或存储单元地址，如间接寻址方式、寄存器间接寻址方式。④ 偏移寻址类。指令通过某种方式给出一个形式地址和一个基地址（在某个寄存器中），经过相应的计算（基地址加形式地址）得到操作数所在的存储单元地址，有变址、相对和基址寻址方式三种。`
    ),
    section('16.直接寻址的操作数要几次访存？')(p`答：一次。只要根据指令中给出的直接地址进行一次存储访问，取出来的就是操作数。`),
    section('17.间接寻址的操作数要进行几次存储访问？')(
        p`答：至少两次。先根据指令中给出的间接地址进行一次存储访问，取出来的是操作数所在的存储单元地址；再根据操作数所在的存储单元地址访存一次，取出来的才是操作数。所以，一共有两次访存。如果是多级间接地址，则要多次访存。`
    ),
    section('18.寄存器寻址的操作数要几次访存？')(p`答：不需要访存。从指定寄存器中取出的就是操作数。`),
    section('19.寄存器间接寻址的操作数要几次访存？')(
        p`答：一次。先从指令给出的寄存器中取出操作数所在的存储单元地址，再根据操作数所在的存储单元地址访存一次，得到的就是操作数。`
    ),
    section('20.什么是变址寻址方式？')(
        p`答：在变址寻址方式下，指令中的地址码给出一个形式地址，并且隐含或明显地指定一个寄存器作为变址寄存器，变址寄存器的内容（变址值）和形式地址相加，得到操作数的有效地址，根据有效地址到内存访问，去取操作数或写运算结果。`,
        p`变址寻址方式的应用很广泛。最基本的使用场合是对数组元素的访问。指令将数组的首地址指定为形式地址，变址寄存器的内容是数组元素的下标，随着下标的变化，可以访问数组中不同的元素。所以变址寄存器的内容是变化的，反映的是所访问的数据到数组首地址的距离，称为变址值。这种应用场合下，形式地址的位数较长，而变址值位数少。变址寻址方式的指令一般包含在一个循环体内。每次进入循环时，变址值都增或减一个定长值，这个定长值等于数组元素的长度。`
    ),
    section('21.什么是基址寻址方式？')(
        p`答：在基址寻址方式下，指令中的地址码给出一个形式地址，作为位移量，并且隐含或明显地指定一个寄存器作为基址寄存器，基址寄存器的内容和形式地址相加，得到操作数的有效地址，根据有效地址到内存访问，去取操作数或写运算结果。`,
        p`基址寻址的典型应用有两个：第一个应用是程序重定位，在多道程序运行的系统中，每个用户程序在一个逻辑地址空间里编写程序。装入运行时，由操作系统给用户程序分配主存空间，每个用户程序有一个基地址，存放在基址寄存器中，在程序执行时，通过基址寄存器的值加上指令中的形式地址就可以形成实际的主存单元地址。第二个应用是扩展有限长度指令的寻址空间。即在运行时将某个存储区的首地址或程序段的首地址装入基址寄存器，而形式地址给出要访问的单元相对于该首地址的距离（即偏移量），因此指令中只要用较短的地址码来表示偏移量。访问操作数时，用基址寄存器的值和偏移量相加，得到操作数所在的存储单元地址。只要基址寄存器的内容更改到另外的一个存储地址，操作数的地址空间就移到另一个存储区间，因此可以访问到整个地址空间，以实现短地址访问大空间的目的。`
    ),
    section('22.变址寻址方式和基址寻址方式的区别是什么？')(
        p`答：变址寻址方式和基址寻址方式的有效地址形成过程类似。但是，基址寻址方式与变址寻址方式在以下两个方面不同：① 具体应用的场合不同。变址寻址面向用户，可用于访问字符串、数组、表格等成批数据或其中的某些元素。基址寻址面向系统，用于解决程序的重定位问题和短地址访问大空间的问题。② 使用方式不同。变址寻址时，指令中提供的形式地址是一个基准地址，位移量由变址寄存器给出；基址寻址时，指令中给出的形式地址为位移量，而基址寄存器中存放的是基准地址。不过，这里所讲的使用方式并不是绝对的，实际中可能会有不同的应用场合和使用方式。`
    ),
    section('23.什么是相对寻址方式？')(
        p`答：相对寻址方式的有效地址形成方法如下：指令中的形式地址给出一个位移量 D，而基准地址由程序计数器 PC 提供。即有效地址为 EA=（PC）+D。位移量给出的是相对于当前指令所在存储单元的距离，位移量可正、可负。也就是说，要找的可以是当前指令前 D 个单元处的信息，也可以是当前指令后 D 个单元处的信息。`
    ),
    section('24.相对寻址方式用在哪些场合？')(
        p`答：相对寻址方式用在以下两种场合。① 公共子程序的浮动。因为公共子程序可能被许多用户程序调用，所以会随着用户程序装入内存不同的地方运行。为了让公共子程序能在不同的内存区正确运行，一般在公共子程序内部采用相对寻址方式，以保证指令的操作数总在相对于指令一定的单元内。这样，不管子程序浮动到哪里，指令和数据的相对位置不变。例如，现行指令的地址为 2000H，指令中给出的形式地址为 05H，说明操作数在当前指令后面第 05H 个单元处，即 2005H 处。当程序向后浮动了 1000H，使当前指令的地址为 3000H 时，此时公共子程序中的指令、数据以及相对位置都不变，指令中给出的相对地址还是 05H，操作数还是应该在当前指令后面的第 05H 个单元处，所以应该在 3005H 处，因此指令取到的还是同一个数据。② 转移目标地址的寻址。当需要转到当前指令的前面或后面第 n 条指令执行时，可以用相对寻址方式，此时得到的转移地址是一个相对地址。例如，调用指令中的目标指令地址多采用相对寻址方式。`
    ),
    section('25.相对寻址方式中如何确定相对位置？')(
        p`答：在相对寻址方式中，相对位置的确定比较复杂。必须注意两个方面的问题：① 位移量的问题。位移量位数有限，在进行有效地址计算时需要扩展。一般位移量用补码表示，所以应采用补码扩展填充方式（即符号扩展方式）。② 基准地址问题。相对寻址的基本思路是把相对于当前指令前面或者后面第 n 个单元作为操作数或目标转移指令的地址。但在具体实现时，不同机器对「当前指令」的含义有不同的理解。有的机器在计算相对地址时，PC 中存放的还是当前正在执行的指令的地址，但有的机器 PC 加「1」的操作在取指令的同时完成，所以在计算相对地址时，PC 中已经是下一条指令的地址。因此，不同的机器在计算相对地址时可能有细微的差别。`
    ),
    section('26.栈寻址方式中如何对栈进行操作？')(
        p`答：栈是一块特殊的存储区，采用「先进后出」的方式进行访问——栈底固定不动，栈顶浮动，用一个专门的寄存器（SP）来作为栈顶指针。从栈生长的方向来分，可以有「自顶向下」和「自底向上」两种，它们在入栈、出栈时对栈指针的修改是不同的。若每个栈中的元素只占一个内存单元，则修改指针时，通过「+1」或「-1」实现；若占多个内存单元，则应该加上或减去相应的存储单元数。`,
        p`假定栈指针指向的总是栈顶处的非空元素，则应该按以下方式修改栈指针。对于「自底向上」生成的栈，入栈时先修改栈指针：（SP）+1→SP，然后再压入数据；出栈时先将数据弹出，然后再修改栈指针：（SP）-1→SP。对于「自顶向下」生成的栈，入栈时先修改栈指针：（SP）-1→SP，然后再压入数据；出栈时先将数据弹出，然后再修改栈指针：（SP）+1→SP。`,
        p`假定栈指针指向的总是栈顶处的空元素，则应该按以下方式修改栈指针。对于「自底向上」生成的栈，入栈时先压入数据，然后再修改栈指针：（SP）+1→SP；出栈时先修改栈指针：（SP）-1→SP，然后再将数据弹出。对于「自顶向下」生成的栈，进栈时先压入数据，然后再修改栈指针：（SP）-1→SP；出栈时先修改栈指针：（SP）+1→SP，然后再将数据弹出。`,
        p`注意：上文中「+1」或「-1」并不是指加/减一个绝对值「1」，而是加/减一个数据所占的存储单元数。例如，IA-32 采用「自顶向下」的方式生成栈，而且栈指针指向的总是栈顶处的非空元素，因此，栈指针 ESP 按照以下方式进行修改：每次将一个 32 位通用寄存器内容入栈（PUSH 指令），则（ESP）-4→ESP；每次将栈顶的 32 位数据出栈装入 32 位通用寄存器中（POP 指令），则（ESP）+4→ESP。`
    ),
    section('27.返回指令要不要有地址字段？')(
        p`答：不一定。子程序（过程）的最后一条指令一定是返回指令。一般返回地址保存在栈中，所以返回指令中不需要明显给出返回地址，直接从栈顶取地址作为返回地址。如果有些计算机不采用栈保存返回地址，而是存放到其他不确定的地方，则返回指令中必须有一个地址码，用来指出返回地址或返回地址的存放位置。`
    ),
    section('28.转移指令和转子（调用）指令的区别是什么？')(
        p`答：转移指令有无条件转移指令和条件转移指令（也叫分支指令）。这种转移指令用于改变程序执行的顺序，转移后不再返回来执行，所以无需保存返回地址。而转子指令是一种子程序调用指令，子程序执行结束时，必须返回到转子指令后面的指令执行。所以转子指令执行时，除了和转移指令一样要计算跳转的目标地址外，还要保存返回地址。一般将转子指令后面那条指令的地址作为返回地址保存到栈或特定寄存器中。`
    )
).elem
