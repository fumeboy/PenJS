import { p, section } from '@src/components/@write'
const title = '7.2　主要内容提要'
const page = section(title)(
    section(`程序与进程的概念`)(
        p`程序指代码和数据的集合，程序的代码是一个机器指令序列，因而程序是一种静态的概念。它可以作为目标模块存放在磁盘中，或者作为一个存储段存在于一个地址空间中。简单来说，进程是程序的一次运行过程，是一个具有一定独立功能的程序关于某个数据集合的一次运行活动，因而进程具有动态的含义。`
    ),
    section(`进程的逻辑控制流`)(
        p`一个可执行目标文件被加载并启动执行后，就成为一个进程。不管是静态链接生成的完全链接可执行文件，还是动态链接后在存储器中形成的完全链接可执行目标，其代码段中的每条指令都有一个确定的地址，在这些指令的执行过程中，会形成一个指令执行的地址序列，对于确定的输入数据，其指令执行的地址序列也是确定的。这个确定的指令执行地址序列称为进程的逻辑控制流。`,
        p`在一个单处理器系统中，通常操作系统会使若干个进程轮流使用处理器，对一个处理器而言，它所执行的所有指令序列（包括交错执行的不同进程所包含的）构成该处理器的物理控制流。因而，在某段时间内轮流调度多个进程在一个处理器上执行时，处理器的物理控制流就由这几个进程的逻辑控制流组成。对某个进程来说，虽然其执行过程可能被打断多次，但是其逻辑控制流不会发生变化。`
    ),
    section(`进程的上下文切换`)(
        p`操作系统通过处理器调度让处理器轮流执行多个进程。实现不同进程中指令交替执行的机制称为进程的上下文切换。上下文切换发生在操作系统调度一个新进程到处理器上运行时，它需要完成以下三件事：① 将当前进程的寄存器上下文保存到系统栈中；② 将新进程系统级上下文中的现场信息作为新的寄存器上下文恢复到处理器的各个寄存器中；③ 将控制转移到新进程执行。这里，一个重要的上下文信息是 PC 的值，当前进程被打断的断点处的 PC 作为寄存器上下文的一部分被保存在进程现场信息中，这样，下次该进程再被调度到处理器上执行时，就可以从其现场信息中获得断点处的 PC，从而能从断点处开始执行。`,
        p`显然，处理器调度等事件会导致进程的正常执行被打断，从处理器上被调度下来的进程的逻辑控制流被打断了，因而形成了突变的异常控制流。进程的上下文切换机制很好地解决了这类异常控制流，实现了从一个进程安全切换到另一个进程执行的过程。`
    ),
    section(`进程的私有地址空间`)(
        p`进程概念的引入除了为应用程序提供了一个独立的逻辑控制流，还为应用程序提供了一个私有的地址空间，使得程序员以为自己的程序在执行过程中独占存储器，这个私有地址空间即虚拟地址空间。`,
        p`整个虚拟地址空间分为两大部分：内核虚拟存储空间（简称内核空间）和进程虚拟存储空间（简称用户空间）。在采用虚拟存储器机制的系统中，每个程序的可执行目标文件在装入时，都被映射到同样的虚拟地址空间上，也即所有用户进程的虚拟地址空间是一致的，只是在相应的只读区域和可读写数据区域中映射的信息不同而已，它们分别映射到对应可执行目标文件中的只读段（.init、.text 和.rodata 节组成的段）和可读写数据段（.data 和.bss 节组成的段）。其中，只有.bss 节在可执行目标文件中没有具体内容，因此，在运行时由操作系统将该节对应的存储区初始化为 0。`
    ),
    section(`程序的加载和运行`)(
        p`介绍可执行目标文件的加载时提到，当启动一个可执行目标文件执行时，首先会通过某种方式调出常驻内存的一个称为加载器的操作系统程序来进行处理。在 UNIX/Linux 系统中，可以通过调用 execve（）函数来启动加载器。加载器将可执行目标文件中的.text 节、.data 节、.bss 节等内容加载到当前进程的虚拟地址空间（实际上并没有将可执行文件中的代码和数据从磁盘读入主存，而是修改了当前进程上下文中关于存储映像的一些数据结构）。当加载器执行完加载任务后，便开始转到程序的第一条指令执行，从此，程序开始在一个进程的上下文中运行。`
    ),
    section(`异常和中断的基本概念`)(
        p`异常和中断会引起用户程序的正常执行被打断，也即异常和中断也是一种异常控制流。异常和中断处理的大致过程如下：当 CPU 在执行当前进程的第 i 条指令时检测到一个异常事件，或在执行第 i 条指令后发现有一个中断请求信号，则 CPU 会打断当前用户进程，然后转到相应的异常或中断处理程序去执行。若异常或中断处理程序能够解决相应问题，则在异常或中断处理程序的最后，CPU 通过执行「异常/中断返回指令」回到被打断的用户进程的第 i 条指令或第 i+1 条指令继续执行；若异常或中断处理程序发现是不可恢复的致命错误，则终止当前进程。通常情况下，对于异常和中断事件的具体处理过程全部由操作系统（可能包括驱动程序）软件来完成。`
    ),
    section(`异常和中断的分类`)(
        p`Intel 将内部异常分为三类：故障（fault）、陷阱（trap）和终止（abort）。故障是在引起故障的指令被启动后但未执行结束时 CPU 检测到的一类与指令执行相关的意外事件。这种意外事件有些可以恢复，有些则不能恢复。例如，指令译码时出现「非法操作码」；取指令或数据时发生「页故障」；执行除法指令时发现「除数为 0」等。陷阱也称为自陷或陷入，与「故障」等其他异常事件不同，是预先安排的一种「异常」事件，就像预先设定的「陷阱」一样。当执行到陷阱指令（也称为自陷指令）时，CPU 就调出特定的程序进行相应的处理，处理结束后返回到陷阱指令的下一条指令执行。陷阱的重要作用之一是在用户程序和内核之间提供一个像过程一样的接口，这个接口称为系统调用，用户程序利用这个接口可以方便地使用操作系统内核提供的一些服务。终止是在程序执行过程中发生了诸如数据校验错等严重错误时而不得不终止当前进程或重启系统的一类异常。`,
        p`Intel 将外部中断分为可屏蔽中断和不可屏蔽中断两类。可屏蔽中断是指通过可屏蔽中断请求线 INTR 向 CPU 进行请求的中断，主要来自 I/O 设备的中断请求，CPU 可以通过在中断控制器中设置相应的屏蔽字来决定屏蔽它或不屏蔽它，若一个 I/O 设备的中断请求被屏蔽，则它的中断请求信号将不会被送到 CPU。不可屏蔽中断通常是非常紧急的硬件故障，通过专门的不可屏蔽中断请求线 NMI 向 CPU 发出中断请求，如电源掉电、硬件线路故障等，这类中断请求信号一旦产生，任何情况下它都不可以被屏蔽，因此一定会被送到 CPU，以便让 CPU 快速处理这类紧急事件。`
    ),
    section(`异常和中断的响应过程`)(
        p`每种处理器架构都会各自定义它所处理的异常和中断类型，而且对于异常和中断的处理，不同的处理器/操作系统平台可能也有所不同，但是它们之间的差别不大，基本原理相同。`,
        p`在 CPU 执行指令过程中，如果发生了异常事件或中断请求，则 CPU 必须进行相应的处理。CPU 从检测到异常或中断事件，到调出相应的异常或中断处理程序开始执行，整个过程称为「异常和中断的响应」。CPU 对异常和中断的响应过程可分为以下三个步骤：保护断点和程序状态、关中断、识别异常和中断事件并转到相应处理程序执行。`,
        p`异常和中断源的识别可以采用软件识别和硬件识别两种方式。软件识别方式是指 CPU 中设置一个原因寄存器，该寄存器中有一些标识异常原因或中断类型的标志信息。操作系统使用一个统一的异常或中断查询程序，该程序按一定的优先级顺序查询原因寄存器，先查询到的先被处理。硬件识别方式称为向量中断方式。这种方式下，异常或中断处理程序的首地址称为中断向量，所有中断向量存放在一个表中，称为中断向量表。每个异常和中断都被设定一个中断类型号，中断向量存放的位置与对应的中断类型号相关，例如，类型 0 对应的中断向量存放在第 0 表项，类型 1 对应的中断向量存放在第 1 表项，……以此类推，因而可以根据类型号快速找到对应的处理程序。`
    ),
    section(`IA-32 的异常/中断处理机制`)(
        p`IA-32 中的异常和中断识别采用向量中断方式，可以处理 256 种不同类型的异常和中断，每个异常或中断都有唯一的编号（称为中断类型号，也称为向量号），并且还有与其对应的异常处理程序或中断服务程序，其入口地址放在一个专门的中断向量表中。例如，类型 0 为「除法错」，类型 2 为「NMI 中断」，类型 14 为「缺页」等。`,
        p`IA-32 在实地址模式下，异常处理程序或中断服务程序的入口地址（由 16 位段地址和 16 位偏移地址组成）称为中断向量，用来存放 256 个中断向量的数据结构就是中断向量表。保护模式下，并不像实地址模式那样将异常处理程序或中断服务程序的入口地址直接填入 00000H～003FFH 存储区，而是借助于中断描述符表来获得异常处理程序或中断服务程序的入口地址。`,
        p`中断描述符表（Interrupt Descriptor Table，IDT）是操作系统内核中的一个表，共有 256 个表项，每个表项占 8 个字节，是一个中断门描述符、陷阱门描述符或任务门描述符。中断门描述符和陷阱门描述符中都会给出一个 16 位的段选择符和 32 位的偏移地址。段选择符用来指示异常处理程序或中断服务程序所在段的段描述符的位置，偏移地址则给出异常处理程序或中断服务程序的第一条指令所在的偏移量。`
    ),
    section(`Linux 对异常/中断的处理`)(
        p`异常和中断的处理由 CPU 和操作系统协调完成。CPU 在执行指令过程中检测到异常或中断事件后，通过对异常和中断的响应，调出异常处理程序或中断服务程序来执行。`,
        p`操作系统负责初始化 IDT 以及编制好异常处理程序或中断服务程序，因而 Linux 内核在启用异常和中断机制之前，需要先设置好每个 IDT 的表项 IDTi（0≤i<256），并把 IDT 的首地址存入 IDTR 寄存器。这个工作是在系统初始化时完成的。`,
        p`Linux 对异常和中断的处理有不同的考虑。对于大部分异常，当 CPU 检测到异常发生后，便通过异常响应机制调出对应的异常处理程序，异常处理程序发送一个对应的信号给发生异常的当前进程，或者故障恢复后返回到当前进程的逻辑控制流中的断点处执行。Linux 采用向发生异常的进程发送信号的机制实现异常处理，可以尽快结束在内核态的异常处理过程。因为异常处理过程越长，嵌套执行异常或中断的可能性越大，而异常和中断的嵌套执行会付出较大的代价。Linux 中处理的中断有 I/O 中断、时钟中断和处理器中断三种类型。因为中断事件的发生与正在执行的当前进程很可能没有关系，因而将一个信号发给当前进程是没有意义的，所以对于中断的处理，Linux 直接执行相应的中断服务程序，针对不同的中断类型进行不同的处理。I/O 中断的相关细节在第 8 章中介绍。`
    ),
    section(`IA-32/Linux 的系统调用`)(
        p`系统调用是一种特殊的「异常事件」，是操作系统为用户程序提供服务的一种手段。Linux 提供了几百种系统调用，主要分为以下几类：进程控制、文件操作、文件系统操作、系统控制、内存管理、网络管理、用户管理和进程通信。`,
        p`在 IA-32/Linux 中，普通函数（包括 API）使用 CALL 指令来实现过程调用，系统调用则使用陷阱指令（如 int$0x80 或 sysenter）来实现。对于过程调用，执行 CALL 指令前后，处理器一直在用户态下执行指令，因此所执行的指令是受限的，所能访问的存储空间也是受限的；而对于系统调用，一旦执行了发出系统调用的陷阱指令，处理器就从用户态转到内核态下运行，此时 CPU 可以执行特权指令并访问内核空间。`
    )
).elem
