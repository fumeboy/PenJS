import { p, section } from '@src/components/@write'
import { multipleChoice, answer } from '@src/components/@questionnaire'
const title = '7.5　单项选择题'
const page = section(title)(
    multipleChoice('1.以下有关计算机程序和进程的描述中，错误的是')(
        p`用高级语言编写的程序必须转换为机器代码才能在计算机中运行`,
        p`机器代码通常以可执行目标文件或共享库文件形式保存在磁盘中`,
        answer(p`机器代码及其数据被映射到统一的虚拟地址空间即形成一个进程`),
        p`同一个程序如果处理不同的数据集合就会对应很多不同的进程`
    ),
    multipleChoice('2.以下关于引入进程好处的叙述中，错误的是')(
        p`每个进程具有确定的逻辑控制流，不会因为进程被打断执行而改变`,
        answer(p`每个进程须独占使用处理器，以保证每次运行都有同样的运行结果`),
        p`每个进程具有独立的虚拟地址空间，便于编译、链接、共享和加载`,
        p`每个进程各自占用不同的主存区域，便于操作系统实现存储保护`
    ),
    multipleChoice('3.以下关于进程的逻辑控制流的叙述中，错误的是')(
        p`进程的逻辑控制流指其运行过程中执行指令的虚拟地址序列`,
        p`不同进程的逻辑控制流中有可能会存在相同的指令地址`,
        p`不同进程的逻辑控制流在时间上交错或重叠的情况称为并发`,
        answer(p`进程的逻辑控制流在其对应机器代码被链接生成时就已经确定`)
    ),
    multipleChoice('4.以下关于进程上下文切换的叙述中，错误的是')(
        p`进程上下文指进程的代码、数据以及支持进程执行的所有运行环境`,
        p`进程上下文切换机制实现了不同进程在一个处理器中交替运行的功能`,
        p`进程上下文切换过程中必须保存换下进程在切换处的程序计数器 PC 的值`,
        answer(p`进程上下文切换过程中必须将换下进程的代码和数据从主存保存到磁盘上`)
    ),
    multipleChoice('5.以下关于 IA-32/Linux 进程虚拟地址空间的叙述中，错误的是')(
        p`分为内核空间和用户空间两大块，各占高地址 1GB 和低地址 3GB 空间`,
        p`用户空间从 0x8048000 开始，由高地址的动态区和低地址的静态区组成`,
        p`用户空间的动态区由栈和堆组成，栈从高地址向低地址生长，而堆相反`,
        answer(p`用户空间的静态区由代码段和数据段组成，数据段由读写数据和只读数据组成`)
    ),
    multipleChoice('6.以下关于 IA-32/Linux 进程内核空间的叙述中，错误的是')(
        p`包含内核程序的代码及其所用的数据信息`,
        answer(p`包含所有进程可以动态链接的共享库映射区`),
        p`包含进程现场信息，如寄存器（硬件）上下文等`,
        p`包含进程标识信息和控制信息，如进程标识符、页表等`
    ),
    multipleChoice('7.以下关于 Linux 系统中 shell 命令行解释器如何进行程序加载和运行的叙述中，错误的是')(
        p`shell 命令行解释器根据输入的命令行信息获得程序名及参数和环境变量`,
        p`shell 命令行解释器可以通过调用 execve（）函数来启动加载器进行程序加载`,
        p`调用 execve（）函数前 shell 命令行解释器先调用 fork（）函数创建一个子进程`,
        answer(p`加载器会把可执行目标文件从磁盘读到内存中，然后从第一条指令开始执行`)
    ),
    multipleChoice('8.以下关于进程上下文切换机制和异常/中断机制比较的叙述中，错误的是')(
        p`进程上下文切换后，CPU 执行的是另一个进程的代码`,
        p`响应异常/中断请求后，CPU 执行的是内核程序的代码`,
        answer(p`进程上下文切换和异常/中断响应处理都通过执行内核程序实现`),
        p`进程上下文切换和异常/中断响应两者都会产生异常控制流`
    ),
    multipleChoice('9.以下选项中，不属于「故障」类的异常是')(p`非法指令操作码`, p`整除时除数为 0`, answer(p`断点设置指令`), p`缺页`),
    multipleChoice('10.以下给出的 IA-32 指令中，不属于陷阱指令的是')(p`int$0x80`, answer(p`iret`), p`int 3`, p`sysenter`),
    multipleChoice('11.以下关于异常/中断响应的叙述中，错误的是')(
        p`异常事件检测由 CPU 在执行每一条指令的过程中进行`,
        p`中断请求检测由 CPU 在每条指令执行结束、取下条指令之前进行`,
        answer(p`CPU 检测到异常事件后所做的处理和检测到中断请求后所做的处理完全一样`),
        p`CPU 在中断请求响应中会保存断点和程序状态、关中断并转到中断服务程序执行`
    ),
    multipleChoice('12.以下关于向量中断方式的叙述中，错误的是')(
        answer(p`使用一个统一的查询程序按响应优先级查询异常和中断，并转具体处理程序执行`),
        p`异常处理程序和中断服务程序的首地址称为中断向量，按序存放在一个中断向量表中`,
        p`每个异常和中断都被设定一个中断类型号，中断向量存放的位置与对应的中断类型号相关`,
        p`IA-32 架构处理器采用向量中断方式调出异常处理程序或中断服务程序执行`
    ),
    multipleChoice('13.以下关于 IA-32 的异常/中断机制的叙述中，错误的是')(
        p`最多可以有 256 种异常和中断类型，每种类型有一个中断号 i（0≤i≤255）`,
        p`在实地址模式下使用中断向量表保存异常处理程序和中断服务程序的首地址`,
        p`在保护模式下通过中断描述符表获取异常处理程序和中断服务程序的首地址`,
        answer(p`中断向量表和中断描述符表中都有 256 个表项，每个表项都占 8 个字节`)
    ),
    multipleChoice('14.以下选项中，不属于中断描述符表中表项内容的是')(
        p`中断门描述符`,
        answer(p`调用门描述符`),
        p`任务门描述符`,
        p`陷阱门描述符`
    ),
    multipleChoice('15.以下关于 IA-32 的中断门描述符的叙述中，错误的是')(
        p`每个中断门描述符占 64 位，与一个中断类型号对应`,
        p`包含对应中断服务程序首地址（段选择符和偏移地址）`,
        answer(p`包含存在位（字段 P），用于表示对应中断类型是否存在`),
        p`包含 DPL 字段，用于表示访问本段时的 CPL 所要求的最低特权级`
    ),
    multipleChoice('16.以下关于 IA-32 保护模式下异常和中断响应处理的叙述中，错误的是')(
        p`处理器在检测到异常事件或中断请求后，获得中断类型号并进入响应阶段`,
        p`处理器根据中断类型号 i 访问 IDTi，再根据 IDTi 中段选择符访问指定段描述符`,
        p`处理器获取内核栈栈顶指针送 SS/ESP，并在内核栈保存 SS/ESP、EFLAGS、CS/EIP`,
        answer(p`异常和中断响应处理结束前 CPU 将对应 IDTi 中的段选择符送 SS，偏移地址送 ESP`)
    ),
    multipleChoice('17.以下关于 IA-32/Linux 异常处理和中断处理的叙述中，错误的是')(
        p`Linux 需要针对 IA-32 的 256 个中断设置 IDT 对应表项的内容，即进行 IDT 的初始化`,
        p`Linux 对大多数异常的处理方式是发送相应信号给用户进程以尽快结束异常处理过程`,
        answer(p`Linux 中异常处理的 C 函数名由 do_前缀和处理程序名组成，与相应信号处理程序名相同`),
        p`Linux 中对中断的处理不采用发送信号给用户进程的方式，而是对相应中断进行具体处理`
    ),
    multipleChoice('18.以下关于 IA-32/Linux 系统调用的叙述中，错误的是')(
        answer(p`系统调用是一种特殊的异常类型，IA-32 中把它的中断类型号设定为 128`),
        p`系统调用使用陷阱指令实现，Linux 系统中可执行 int$0x80 指令进行系统调用`,
        p`执行陷阱指令过程中所完成的操作类似于在异常/中断响应处理过程中完成的任务`,
        p`所有系统调用有一个统一的入口，即系统调用处理程序 system_call 第一条指令地址`
    ),
    section('部分题目的答案解析')(
        section('第 1 题')(
            p`进程是指程序的一次运行过程，是一个具有一定独立功能的程序关于某个数据集合的一次运行活动，因而进程具有动态的含义。而在选项 C 中提到的机器代码及所处理的数据被映射到统一的虚拟地址空间这个过程是在链接过程中完成的，链接后生成的可执行目标文件只是一个静态的程序形式，只有装入运行才会成为一个进程，因而选项 C 的说法是错误的。`
        ),
        section('第 2 题')(
            p`引入进程概念后，通过进程上下文切换可以保证每个进程具有确定的逻辑控制流，不管进程被打断几次或者在哪里被打断，每次运行都有同样的运行结果，因而进程可以交替使用处理器，而不需要独占使用处理器。显然，选项 B 的说法是错误的。`
        ),
        section('第 3 题')(
            p`对于选项 A，进程的逻辑控制流指其运行过程中执行指令所在的虚拟地址序列。选项 A 说法正确。`,
            p`对于选项 B，因为逻辑控制流是指进程的虚拟地址序列，而每个进程都是映射到独立的虚拟存储空间，起始地址都一样，因而不同进程的逻辑控制流中可能会存在相同的指令地址。选项 B 说法正确。`,
            p`对于选项 C，两个进程是并发的，是指这两个进程在时间上交错或重叠执行，显然，这种情况下它们的逻辑控制流在时间上是交错或重叠的。选项 C 说法正确。`,
            p`对于选项 D，虽然链接时机器代码已被映射到虚拟地址空间，即每条指令的虚拟地址已经确定，但是，在执行过程中 CPU 应该执行哪些指令还取决于所操作的数据，而有些数据可能是进程执行过程中动态获得的，因而进程的逻辑控制流也会随着不同数据的输入而不同。因而选项 D 的说法是错误的。`
        ),
        section('第 4 题')(
            p`进程上下文指进程的代码、数据以及支持进程执行的所有运行环境，进程上下文切换机制保证了一个进程的执行可以被其他进程打断，因而实现了不同进程在一个处理器中交替运行的功能。为了保证进程被打断后能够从被打断处重新继续执行，在进程上下文切换过程中，必须保存换下进程在切换处的程序计数器 PC 的值（如 IA-32 中 CS/EIP 的值），不过，换下进程的代码和数据没有必要保存到磁盘上。由此可见，选项 A、B 和 C 的说法都是正确的，而选项 D 的说法是错误的。`
        ),
        section('第 5 题')(
            p`IA-32/Linux 进程虚拟地址空间中的用户空间静态区由只读代码段和可读可写数据段组成，只读代码段包含程序代码和只读数据（如.text 节和.rodata 节），可读写数据段包括各种全局变量和静态变量存储区（如.data 节和.bss 节）。因此，选项 D 的说法是错误的。`
        ),
        section('第 6 题')(
            p`IA-32/Linux 进程内核空间不包含动态链接用的共享库映射区，它在用户空间的动态存储区，位于堆和栈的中间。因此，选项 B 的说法是错误的。`
        ),
        section('第 7 题')(
            p`加载器对可执行目标文件进行加载时，实际上不会把可执行目标文件从磁盘读到内存中，只是修改当前进程上下文中关于存储映像的一些数据结构。因此，选项 D 的说法是错误的。`
        ),
        section('第 8 题')(
            p`进程上下文切换是由操作系统内核程序实现的，而异常/中断响应处理是由处理器这个硬件实现的，在进行异常/中断响应处理过程中无需执行任何指令。因此，选项 C 的说法是错误的。`
        ),
        section('第 9 题')(p`非法指令操作码、整除时除数为 0 和缺页都属于故障类异常；而断点设置指令是陷阱指令，属于陷阱类异常。因此，答案为 C。`),
        section('第 10 题')(
            p`指令 int$0x80、int 3 和 sysenter 都是陷阱指令，会引起用户态向内核态的转换，其中，int$0x80 和 sysenter 是系统调用指令，int 3 是断点设置指令。iret 则不是陷阱指令，执行 iret 指令不会发生从用户态陷入内核态的情况。因此，答案为 B。`
        ),
        section('第 11 题')(
            p`CPU 检测到异常事件后所做的处理和检测到中断请求后所做的处理大部分是一样的，但是有个别地方可能不一样，例如，对于故障类异常，因为其断点为发生故障的指令的地址，所以要重新计算 PC 的值，而中断的断点就是当前 PC 的值，因此无需重新计算 PC 的值。此外，在有些系统中，CPU 是否关中断，对于异常和中断来说也可能不同，例如，在 IA-32 中，通过中断门进入一个中断服务程序时，CPU 会清除 EFLAGS 寄存器中的 IF 标志，即关中断；而在通过陷阱门进入一个异常处理程序时，CPU 不会修改 IF 标志。由此可见，选项 C 的说法是错误的。`
        ),
        section('第 13 题')(
            p`在实地址模式下，异常处理程序或中断服务程序的入口地址（由 16 位段地址和 16 位偏移地址组成）称为中断向量，用来存放 256 个中断向量的数据结构就是中断向量表。因此，实地址模式下每个中断向量占 4 个字节。因此，选项 D 的说法是错误的。`
        ),
        section('第 16 题')(p`异常和中断响应处理结束前，CPU 将对应 IDTi 中的段选择符送 CS，偏移地址送 EIP，因此选项 D 的说法是错误的。`),
        section('第 18 题')(
            p`系统调用使用陷阱指令实现，因而是一种特殊的异常类型。Linux 系统中可执行 int$0x80 指令进行系统调用，因此，系统调用对应的中断类型号为 0x80=128，不过，这是 Linux 操作系统设定的，而不是由 IA-32 设定的。Windows 操作系统中通过执行 int$0x2e 指令发出系统调用，因此对应的中断类型号为 0x2e=46。因此，选项 A 的说法是错误的。`
        )
    )
).elem
