import { p, section } from '@src/components/@write'
const title = '7.4　常见问题解答'
const page = section(title)(
    section('1.主要有哪几类事件会引起异常控制流？')(
        p`答：以下几类事件会引起异常控制流：① 进程的上下文切换。因为进程上下文切换意味着原来在 CPU 上正在执行的进程将被暂时中断，操作系统执行相应的上下文切换程序，将另外一个进程切换到 CPU 上执行。② 发生内部异常事件。某个进程在执行过程中若发生内部异常事件，则 CPU 会对异常事件进行相应的处理，通过执行一系列的操作步骤，最终把操作系统内核中相应的异常处理程序调出来执行。③ 发生外部中断请求。某个进程在执行过程中若发生外部中断请求，则 CPU 会在当前指令执行结束后响应中断请求，通过执行一系列的操作步骤，最终把操作系统内核中相应的中断服务程序调出来执行。以上这些事件都会打断原来程序的正常执行，因而会产生一个异常控制流。`
    ),
    section('2.进程和程序之间最大的区别在哪里？')(
        p`答：进程指程序的一次运行过程，是一个具有一定独立功能的程序关于某个数据集合的一次运行活动，因而进程具有动态的含义。程序就是代码和数据的集合，程序的代码是一个机器指令序列，因而程序是一种静态的概念，它可以作为目标文件模块存放在磁盘中，或者作为一个存储段存在于一个地址空间中。因此，进程和程序之间的最大区别就是程序是静态的概念，而进程是动态的概念。一个程序被启动执行后就变成了一个进程。`
    ),
    section('3.进程的上下文信息主要包含哪些信息？')(
        p`进程的上下文信息主要包含三大块：用户级上下文、系统级上下文和寄存器上下文。用户级上下文由进程的程序块、数据块、运行时的堆和用户栈（通称为用户堆栈）等组成的用户空间信息组成；系统级上下文由进程标识信息、进程现场信息、进程控制信息和系统内核栈等组成的内核空间信息组成。进程控制信息包含各种内核数据结构，例如，记录有关进程信息的进程表（process table）、页表、文件表等。用户级上下文地址空间和系统级上下文地址空间一起构成一个进程的整个存储器映像，实际上就是进程的虚拟地址空间。处理器中各个寄存器的内容被称为寄存器上下文（也称硬件上下文）。`
    ),
    section('4.在进行进程上下文切换时，操作系统主要完成哪几项工作？')(
        p`答：在进程上下文切换时，操作系统需要完成以下三件事：① 将当前进程的寄存器上下文（即现场信息）保存到当前进程的系统级上下文的现场信息中；② 将新进程的系统级上下文中的现场信息作为新的寄存器上下文恢复到处理器的各个寄存器中；③ 将控制转移到新进程执行。`
    ),
    section('5.进程的引入为应用程序提供了哪两个方面的假象？这种假象带来了哪些好处？')(
        p`答：进程的引入为应用程序提供了以下两方面的抽象：一个独立的逻辑控制流和一个私有的虚拟地址空间。每个进程拥有一个独立的逻辑控制流，使得程序员以为自己的程序在执行过程中独占处理器；每个进程拥有一个私有的虚拟地址空间，使得程序员以为自己的程序在执行过程中独占存储器。`,
        p`程序员和语言处理系统把一台计算机的所有资源看作由自己的程序独占，都以为自己的程序是在处理器上执行的和在存储空间中存放的唯一的用户程序。显然，这是一种「错觉」。这种「错觉」带来了极大的好处，它简化了程序员的编程以及语言处理系统的处理，即简化了编程、编译、链接、共享和加载等整个过程。`
    ),
    section(
        '6.「一个进程不管中间是否被其他进程打断，也不管被打断几次或在哪里被打断，它的逻辑控制流总是确定的，这样就可以保证一个进程的执行不管怎样被打断其行为总是一致的。」计算机系统主要靠什么机制实现这个能力？'
    )(
        p`答：计算机系统中主要由操作系统和 CPU 硬件提供的进程上下文切换机制、异常/中断处理机制来保证能够实现题目中描述的这种能力。不管是进程上下文切换机制，还是异常/中断处理机制，都能够保存被中断进程的断点、所有现场以及状态信息，以保证被打断执行的进程下次能够从被打断的地方继续正确地运行下去。`
    ),
    section('7.在 IA-32/Linux 系统平台中，一个进程的虚拟地址空间布局是怎样的？')(
        p`答：如图 7.1 所示，整个虚拟地址空间分为两大部分：内核虚拟存储空间（简称内核空间）和进程虚拟存储空间（简称用户空间）。在采用虚拟存储器机制的系统中，每个程序的可执行目标文件在装入时，都被映射到同样的虚拟地址空间上，也即所有用户进程的虚拟地址空间是一致的，只是在相应的只读区域和可读写数据区域中映射的信息不同而已，它们分别映射到对应可执行目标文件中的只读段（init、.text 和.rodata 节组成的段）和可读写数据段（data 和.bss 节组成的段）。其中，只有.bss 节在可执行目标文件中没有具体内容，因此，在运行时由操作系统将该节对应的存储区初始化为 0。`,
        p`img('undefined')('https://pic3.zhimg.com/v2-47dec60a89c5db64e7856bc184ff196e_r.jpg'),`,
        p`图 7.1　IA-32/Linux 系统虚拟地址空间（主教材中图 7.4）`,
        p`对于 IA-32，其内核虚拟存储空间在 0xc0000000 以上的高端地址上，用来映射到操作系统内核代码和数据、物理存储区，以及与每个进程相关的系统级上下文数据结构（如进程标识信息、进程现场信息、页表等进程控制信息以及内核栈等），其中内核代码和数据区在每个进程的地址空间中都相同。用户程序没有权限访问内核空间。`,
        p`用户空间用来映射到用户进程的代码、数据、堆和栈等用户级上下文信息。每个区域都有相应的起始位置，堆区和栈区相向生长。对于 IA-32，其用户栈区从内核起始位置 0xc0000000 开始向低地址增长，堆栈区中的共享库映射区域从 0x40000000 开始向高地址增长，只读区域从 0x08048000 开始向高地址增长，只读区域后面跟着可读写数据区域，其起始地址通常要求按 4KB 字节对齐。对于 x86-64，其最开始的只读区域从 0x40000000 开始。`
    ),
    section('8.异常和中断事件形成的异常控制流与进程上下文切换引起的异常控制流有何不同？')(
        p`答：在一个进程正常运行过程中，可能会出现一些特殊事件，这些事件的发生将导致当前进程无法继续执行下去。这类特殊事件如：用户按下〈Ctrl+C〉组合键，当前指令执行时发生了指令无法继续执行的意外事件（如整数除法指令中除数为 0、非法指令操作码、访存时地址越界等），I/O 设备完成了系统交给的任务需要系统进一步处理等。这些特殊事件统称为异常（exception）或中断（interrupt）。`,
        p`发生异常或中断时，CPU 必须转到具体的处理特殊事件的异常处理程序或中断服务程序去执行，因而正在执行的进程的逻辑控制流被打断，从而引起一个异常控制流。`,
        p`不过，这种异常控制流与上下文切换引起的异常控制流有一个明显的不同：进程上下文切换后，CPU 执行的是另一个用户进程；而对于中断或异常引起的异常控制流，其调出的异常处理程序或中断服务程序并不是一个进程，而是一个「内核控制路径」，异常处理程序或中断服务程序是代表异常或中断发生时正在运行的当前进程在内核态执行的一个独立指令序列。它作为一个内核控制路径，比进程更「轻」，其上下文信息比一个进程的上下文信息少得多。`
    ),
    section('9.调试程序时的单步跟踪是通过什么机制实现的？')(
        p`答：调试程序时单步跟踪是通过陷阱机制实现的。例如，在 IA-32 中，当 CPU 处于单步跟踪状态（TF=1 且 IF=1）时，每条指令都被设置成了陷阱指令，执行每条指令后，都会发生中断类型号为 1 的「调试」异常，从而转去执行特定的「单步跟踪处理程序」。该程序将当前指令执行的结果显示在屏幕上。单步跟踪处理过程中，CPU 会自动把标志寄存器压栈，然后将 TF 和 IF 清 0，这样在单步跟踪处理程序执行过程中，CPU 能以正常方式工作。单步处理结束、返回到断点处执行之前，再从栈中取出标志，以恢复 TF 和 IF 的值，使 CPU 回到单步跟踪状态，这样下条指令又是「陷阱」指令，将被跟踪执行。如此下去，每条指令都被跟踪执行，直到将 TF 或 IF 清 0 为止。注意，对于「单步跟踪」这类陷阱，当陷阱指令是转移指令时，处理后不能返回到转移指令的下条指令执行，而是返回到转移目标指令执行。`
    ),
    section('10.在异常和中断的响应过程中，CPU（硬件）会保存哪些信息？')(
        p`答：在异常和中断响应过程中，CPU 保存的最基本信息应该包括断点（中断处理后返回的地址）、断点处的机器状态（如各种标志信息）。`,
        p`实际上，在具体实现中可能会更加复杂一些。例如，对于 IA-32 架构，CPU 在响应异常和中断请求过程中，会保存用户栈的 SS 和 ESP（用户栈栈顶指针）、EFLAGS（机器状态）、CS 和 EIP（断点）。`
    ),
    section('11.在异常处理程序或中断服务程序执行过程中，由软件保存哪些信息？')(
        p`答：在异常处理程序或中断服务程序执行过程中，通过执行若干条指令来保存的信息主要是通用寄存器中的内容（称为现场信息）。`
    ),
    section('12.过程（函数）调用和系统调用之间有哪些相同之处？有哪些不同之处？')(
        p`答：过程调用机制采用过程调用指令（或转子指令，如 IA-32 中的 call 指令）和过程返回指令（如 IA-32 中的 ret 指令），而系统调用机制采用陷阱类指令（如 IA-32 中的 int$0x80 和 sysenter 指令）和异常/中断返回指令（如 IA-32 中的 iret 和 sysexit 指令）。`,
        p`过程调用和系统调用的相同之处是，它们都会从一个程序段跳转到另一个程序段执行，而且都会返回到被打断的程序段继续执行。它们之间的不同之处是：过程调用是在同一个进程内的代码之间进行跳转，而且不会改变运行级别；系统调用则是从用户态下执行的用户进程代码陷入内核态的操作系统内核代码去执行，相当于进行一个特殊的异常处理，因而执行 iret 或 sysexit 指令返回时，需要从内核态返回到用户态。显然，系统调用指令执行的开销比过程调用指令执行的开销大得多。`
    ),
    section('13.在 IA-32 中，中断向量表和中断描述符表各自记录了什么样的信息？')(
        p`答：在 IA-32 实地址模式下，异常处理程序或中断服务程序的入口地址（由 16 位段地址和 16 位偏移地址组成）称为中断向量，用来存放 256 个中断向量的数据结构就是中断向量表。由于在实地址模式下每个中断向量占 4 个字节，其中高 16 位是段地址，低 16 位是偏移地址，因此 256 个中断向量组成的中断向量表需要 256×4B=1KB 内存空间，并固定在 00000H～003FFH 的内存区域内。`,
        p`IA-32 的保护模式并不像实地址模式那样将异常处理程序或中断服务程序的入口地址直接填入 00000H～003FFH 存储区，而是借助于中断描述符表来获得异常处理程序或中断服务程序的入口地址。中断描述符表（Interrupt Descriptor Table，IDT）是操作系统内核中的一个表，共有 256 个表项，每个表项占 8 个字节，因而 IDT 共占用 256×8B=2KB 内存空间。`,
        p`每一个表项是一个中断门描述符、陷阱门描述符或任务门描述符。图 7.2 所示为中断门描述符格式。`,
        p`img('undefined')('https://pic1.zhimg.com/v2-7b7c2dc53d6888ea2275390bdfbacd79_r.jpg'),`,
        p`图 7.2　中断门描述符格式`,
        p`陷阱门描述符和任务门描述符的格式类似于中断门描述符。其中，都有字段 P 和 DPL，P=1 表示段存在，P=0 表示段不存在。Linux 总是把 P 置 1，因为它从来不会把一个段交换到磁盘上，而是以页面为单位交换。DPL 给出访问本段要求的最低特权等级。因此，DPL 为 0 的段只能当 CPL 为 0（内核态）时才可访问，而对于 DPL 为 3 的段，任何进程都可以访问。在 DPL 后面的一位都是 0，再后面 4 位用来标识门的类型（TYPE）。若是中断门，则 TYPE=1110B；若是陷阱门，则 TYPE=1111B；若是任务门，则 TYPE=0101B。`,
        p`中断门描述符和陷阱门描述符中都会给出一个 16 位的段选择符和 32 位的偏移地址。段选择符用来指示异常处理程序或中断服务程序所在段的段描述符在 GDT 中的位置，偏移地址则给出异常处理程序或中断服务程序第一条指令所在的偏移量。Linux 利用陷阱门来处理异常，利用中断门来处理中断。因为异常和中断对应的处理程序都属于内核代码段，所以，所有中断门和陷阱门的段选择符都指向 GDT 中的「内核代码段」描述符。`
    ),
    section(
        '14.IA-32 和 Linux 分别代表了硬件和软件（操作系统内核），根据它们各自在整个异常和中断处理过程中所做的具体工作，能否归纳总结出硬件和软件在异常和中断处理过程中分别完成哪些主要工作？'
    )(
        p`答：在异常和中断处理过程中，硬件主要包括 CPU 和 I/O 模块两方面的工作，I/O 模块主要是针对中断处理。`,
        p`（1）CPU 在执行指令过程中需要对各种异常事件进行检测，例如，是否在取指令时发生了缺页故障（page fault），是否在指令译码时发生了非法操作，是否整除指令的除数为 0，是否取数时发生缺页故障，是否执行的是陷阱指令，是否是单步跟踪等。如果发生了以上任何异常事件，则 CPU 根据检测结果得到异常类型号，然后进入异常响应处理阶段。`,
        p`（2）CPU 在执行完每条指令、取下条指令之前，要检测中断请求线（包括不可屏蔽中断请求线）是否有效，若发现有中断请求，则通过中断查询线发出中断回答信号，启动中断控制器对所有未被屏蔽的中断请求信号根据响应优先级进行排队，中断控制器选择响应优先级最高的中断请求，生成相应的中断类型号，通过数据总线回送给 CPU，CPU 得到中断类型号后，进入中断响应处理阶段。`,
        p`（3）在异常或中断响应处理阶段，CPU 要完成从发生异常或中断的进程的执行转到在内核态下异常处理程序和中断服务程序的执行，这个过程通常需要完成三个操作：保存断点和程序状态、关中断、根据异常或中断类型号转到异常处理程序或中断服务程序的第一条指令执行。随后的处理就由软件来完成。`,
        p`在异常和中断处理过程中，当 CPU 完成对异常或中断的响应处理后，就会调出异常处理程序或中断服务程序，因此，软件对异常和中断处理主要是在异常处理程序或中断服务程序中进行的处理。对于不同异常和中断类型，其对应处理程序的功能也完全不同。`,
        p`此外，软件（操作系统）还需要对异常处理程序和中断服务程序以及相应的中断向量表或中断描述符表进行初始化工作。`
    )
).elem
