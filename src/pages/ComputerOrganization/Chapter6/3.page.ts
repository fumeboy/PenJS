import { p, section } from '@src/components/@write'
const title = '6.3　基本术语解释'
const page = section(title)(
    section('随机访问存储器（Random Access Memory，RAM）')(
        p`根据地址译码结果选择某个单元进行读写，对于一个存储器芯片来说，所有单元的地址位数一样，所以每个单元的地址译码所用时间一样。从这个角度来说，这种存储器中每个单元的存取时间与存储单元的物理位置无关。`
    ),
    section('相联存储器（CAM，Content Addressed Memory 或 Associate Memory，AM）')(
        p`已知要访问信息的部分内容，通过比较找到需访问信息的位置，然后读写信息，如全相联 cache。相联存储器的特点就是按内容访问，而不是像 RAM 或 ROM 那样按地址访问。`
    ),
    section('静态随机访问存储器（Static RAM，SRAM）')(
        p`靠触发器的双稳态正负反馈电路存储信息，因而速度快，是非破坏性读出，但电路中元器件多，因而集成度小，适合做高速小容量的高速缓冲存储器（cache）。`
    ),
    section('动态随机访问存储器（Dynamic RAM，DRAM）')(
        p`靠电容存储电荷来保存信息。若电容上存有足够多的电荷表示存「1」，电容上无电荷表示存「0」。是破坏性读出，读后需要再生，而且需要定时刷新。`
    ),
    section('易失性存储器（volatile memory）')(p`电源掉电后，存储器中的信息全部消失，如 cache、RAM 等。`),
    section('非易失性存储器（nonvolatile memory）')(p`存储器中的信息不会因为电源掉电而消失，如 ROM、磁盘、光盘、闪存（Flash 存储器）等。`),
    section('记忆单元（存储基元、存储元）（memory cell）')(
        p`记忆单元是具有两种稳态的能够表示二进制数码 0 和 1 的物理器件，一个记忆单元表示一位信息。`
    ),
    section('存储单元（memory unit）')(
        p`主存中具有相同地址的那些位构成一个存储单元。因此，存储单元的宽度等于一个编址单位的长度，可以是 8 位、16 位、32 位等。现在，大多数计算机是按字节编址的，即每一个字节（8 位）有一个地址，编址单位就是一个字节，所以一个存储单元的宽度是 8 位。`
    ),
    section('存储器地址寄存器（Memory Address Register，MAR）')(
        p`存储器地址寄存器是 CPU 中用来存放存储器地址的寄存器。地址在送到存储器总线的地址线之前，先寄存在 MAR 中。因此，它的宽度应该等于地址线的宽度，也等于主存地址位数，其值决定了主存最大的寻址空间。`
    ),
    section('存储器数据寄存器（Memory Data Register，MDR）')(
        p`存储器数据寄存器是 CPU 中用来存放写入主存或从主存读出的数据的寄存器，数据在送到存储器总线的数据线之前或从主存读到 CPU 时，都先寄存在 MDR 中。因此，它的宽度应该等于数据线的宽度。`
    ),
    section('存取时间（access time）')(
        p`存取时间是指执行一次读操作或写操作的时间，分读出时间和写入时间。读出时间为从主存接收到有效地址开始到数据取出有效为止的时间；写入时间是从主存接收到有效地址开始到数据写入被写单元为止的时间。`
    ),
    section('存储周期（memory Cycle time）')(p`存储周期 Tm 是指存储器进行连续两次独立的读或写操作所需的最小时间间隔。`),
    section('存储器带宽（bandwidth）')(
        p`存储器带宽是指每秒从存储器进/出信息的最大数量。假设存储周期为 50ns，每个存储周期最多可存取 64 位数据，则带宽为 1.28Gbit/s。通常存储器被组织成多模块存储器，能够多个模块同时进行读写，因而存储器带宽为一个存储模块带宽的若干倍。`
    ),
    section('片选信号（Chip Select，CS）')(
        p`一个存储芯片的容量往往满足不了计算机对存储容量的要求，所以需要将一定数量的芯片按一定方式连接成一个完整的存储器。在访问某个字时，必须「选中」该字所在的芯片，而使其他芯片不被「选中」。控制芯片是否被选中的信号即片选信号 CS。`
    ),
    section('地址引脚复用（address pin multiplexing）')(
        p`DRAM 芯片采用二维译码方式，为了减少引脚个数，把行地址和列地址用同一组地址引脚线分时进行传送。靠行地址选通信号和列地址选通信号来区分在地址引脚线上传送的是行地址还是列地址。`
    ),
    section('行地址选通信号（Row Address Strobe，RAS）')(p`DRAM 芯片中，行地址选通信号有效时，说明在地址引脚线上传输的是行地址信号。`),
    section('列地址选通信号（Column Address Strobe，CAS）')(p`DRAM 芯片中，列地址选通信号有效时，说明在地址引脚线上传输的是列地址信号。`),
    section('只读存储器（Read Only Memory，ROM）')(
        p`这种存储器的原始信息一旦被写入，在程序执行过程中，只能对其内容进行读出，而不能写入。只读存储器通常用来存放固定不变的信息。`
    ),
    section('掩膜 ROM（mask ROM）')(
        p`掩膜 ROM 是由厂家在生产过程中一次形成的，即信息已经完全固化在芯片中，无法修改。其结构类似于字片式 RAM，没有写入机构。这类 ROM 适合于大批量生产。`
    ),
    section('可编程只读存储器（Programmable ROM，PROM）')(p`可编程只读存储器在使用时由使用者专门一次写入，以后再也不能改变。`),
    section('可擦除可编程只读存储器（Erasable PROM，EPROM）')(
        p`可擦除可编程只读存储器可以用特殊的装置反复擦除和重写。一般将芯片放在紫外线下照射 15～20min，即可将信息全部擦除。`
    ),
    section('电可擦除可编程只读存储器（Electrically Erasable PROM，EEPROM）')(
        p`电可擦除可编程只读存储器使用电可擦除技术（加高电压擦除），可擦除个别单元。写操作比读操作化更多的时间。其集成度比 EPROM 低，而且更贵。`
    ),
    section('闪存（flash memory）')(
        p`闪存是一种新型的非易失性存储器。它不像 RAM 那样需要电源支持才能保存信息，又像 RAM 一样具有可写性。在某种低电压下，其内容可读不可写，此时类似于 ROM；在一种高电压下，信息可更改或删除，此时又类似于 RAM。闪存常用于存储主板 BIOS 程序，或用作数码相机存储卡和优盘，也可做成固态硬盘以代替磁盘存储器作为辅助存储器使用。`
    ),
    section('双口 RAM（dual-port RAM）')(
        p`双口 RAM 是并行存储结构中的一种。双口 RAM 利用的是空间并行技术，它为一个存储体提供两组独立的读写控制电路和两个读写端口，因而可以对两个数据进行并行的读写。`
    ),
    section('多模块存储器（multi-module memory）')(
        p`多模块存储器包含多个小体，但每个小体有其自己的 MAR、MDR 和读写电路，可独立组成一个存储模块。根据不同的编址方式可分为连续编址和交叉编址。`
    ),
    section('低位交叉编址（low-order interleaving）')(
        p`低位交叉编址也称为交叉编址，低位表示存储器模块号，高位表示存储器模块内地址，使地址交叉分散在各模块内。`
    ),
    section('高位交叉编址（high-order interleaving）')(
        p`高位交叉编址也称为连续编址，主存地址高位表示存储器模块号，低位表示存储器模块内地址，使地址在同模块内连续编址。`
    ),
    section('磁道（track）')(
        p`磁盘在高速旋转时，磁头相对于磁盘表面做相对运动。相对运动时，磁头在盘面上所经过的路径构成一个磁道。磁头在不同的位置，磁盘表面就形成不同半径的同心圆，因此，每个同心圆为一个磁道。每个磁道都有一个编号，最外面的是 0 磁道。`
    ),
    section('柱面（cylinder）')(
        p`在一个磁盘驱动器中的若干个盘片都连到同一个中心轴上，每个可读写的盘面上都有一个磁头，这些不同盘面上的磁头被连在一起且同时按相同的轨迹移动。因此，在不同盘面上的磁头总是处在相同半径的磁道上，所有盘面上的这些磁道构成一个柱面。因此，柱面号和磁道号是一样的。磁头号和盘面号是一样的。`
    ),
    section('扇区（sector）')(
        p`每个磁道被划分为若干段（段又叫扇区），每个扇区的存储容量为 512 字节或 4096 字节。每个扇区都有一个编号。扇区是磁盘的最小编址单位，因此，到磁盘上寻找数据时，只需定位到相应的扇区。读写数据时可能会以多个扇区为单位进行传输。`
    ),
    section('道密度（track density）')(p`沿磁盘半径方向单位长度上的磁道数称为道密度。道密度的单位是道/mm（TPM）。道密度是相邻磁道间距的倒数。`),
    section('位密度（bit density）')(
        p`沿磁道方向上单位长度所记录的二进制信息位称为位密度或线密度，早期的磁盘，每个磁道所含信息量一样。这样的磁盘因为每个磁道的周长不同，使得每个磁道的位密度也不同。一般磁盘的位密度是指最内圈上的位密度，单位是位/毫米。现在也有一些磁盘的磁道采用固定位密度方式，因而在外圈的磁道上可以比内圈的磁道上多记录一些信息。`
    ),
    section('磁盘平均存取时间（average access time）')(
        p`操作系统必须通过三个步骤对磁盘进行操作：寻道（seek）、旋转（rotation）、读写数据。因为读写数据所用时间相对于前两个操作而言，可以忽略不计，所以，通常将前两个操作时间的平均值之和称为磁盘平均存取时间，即平均存取时间等于平均寻道时间加平均旋转时间。`
    ),
    section('平均寻道时间（average seek time）')(
        p`移动磁头使其定位到要读写的磁道上的操作称为寻道（seek）。平均寻道时间取决于相邻两道之间的寻道时间（称为道间移动时间，工业上也把它称为最小寻道时间）。平均寻道时间有很多种测量方法，最简单的方法就是把最长寻道时间除以 2。最长寻道时间就是从最内（外）移过所有磁道到最外（内）的时间。`
    ),
    section('平均旋转时间（average rotational latency/delay）')(
        p`磁头定位在要读写的磁道后，磁盘开始旋转，直到磁头正好落在要读写的数据上方，通常把完成这个过程的时间称为旋转（等待）时间。平均旋转时间是磁盘转一圈的时间的一半。`
    ),
    section('传输时间（transfer time）')(
        p`当磁头正好落在要读写数据的起点后，就开始读/写数据，磁盘读/写一块数据（即一个扇区）的时间称为传输时间。它是扇区大小、旋转速度、磁道上位密度的函数。`
    ),
    section('磁盘数据传输率（transfer rate）')(
        p`磁盘数据传输率分为外部数据传输率和内部数据传输率两种。外部数据传输率指主机接口从（向）硬盘缓存读出（写入）数据的速度；内部数据传输率指磁头定位在要读写的数据块的始端后，单位时间内连续从磁道中读出或写入的二进制数据的位数。`
    ),
    section('磁盘控制器（disk controller）')(
        p`磁盘控制器是指用来控制磁盘进行数据读写，并控制数据在磁盘和主存间进行传输的部件。因此，一次磁盘读写操作除了寻道、旋转、传输三个操作时间以外，还要加上磁盘控制器所用的时间。`
    ),
    section('高速缓存（cache）')(
        p`高速缓存是位于 CPU 和主存之间的一个高速小容量的存储器，在访问主存前先到该存储器访问。如果将当前正在访问的那个存储单元所在的主存块放到该存储器中，根据程序访问的局部化特性，这个主存块中的信息应该是最近经常要访问的，所以不必再到主存去访问，这样就可很快得到所要的信息。`
    ),
    section('访问局部性（access locality）')(
        p`对大量程序调查发现，程序在执行过程中产生的访存要求，其地址具有局部化特性。也就是说，在一个小的时间段内，存储器访问的地址大多在一个局部空间内。访问局部性体现在时间和空间两个方面，可分为时间局部性和空间局部性两种。`
    ),
    section('时间局部性（temporal locality）')(p`时间局部性是指刚刚被访问的单元很可能在一个很短的时间内被再次访问。`),
    section('空间局部性（spatial locality）')(p`空间局部性是指刚刚被访问的单元的临近单元很可能不久也会被访问。`),
    section('命中率（hit rate）')(
        p`命中率是指在快速的缓存中得到信息的概率。例如，在总共 100 次访问中，能在 cache 中访问到信息的次数为 99 次，则命中率为 99%。`
    ),
    section('命中时间（hit time）')(p`命中时间是指在命中情况下的访问时间，包括判断是否命中的时间和在快速存储器中的访问时间两部分。`),
    section('缺失率（miss rate）')(
        p`有些中文书翻译成「失靶率」或「失效率」，就是指没有命中的概率。例如，在总共 100 次访问中，能在 cache 中访问到信息的次数为 99 次，则缺失率为 1%。`
    ),
    section('缺失损失（miss penalty）')(p`缺失损失是指在缺失情况下，从主存取一个数据块到 cache 的时间。`),
    section('主存块（block）')(
        p`主存块是指主存和 cache 之间进行信息交换的单位。把主存分成大小相等的块，主存块从 0 开始编号。访问某个主存单元时，就把这个单元所在的一个主存块调到 cache，根据程序访问的局部性特点，在随后的一段时间内，CPU 很可能要经常访问这个主存块，因为该主存块已调到 cache，所以就不需访问主存了。`
    ),
    section('cache 槽（slot）或 cache 行（line）')(
        p`cache 由若干行组成，每一行中有一个用于存放主存块的槽，其大小与主存块一样，cache 行也从 0 开始编号，cache 行号就是槽号。`
    ),
    section('直接映射 cache（direct-mapped cache）')(
        p`直接映射是指把主存的每一块映射到 cache 的一个固定行中。这样，「主存块号」和「cache 行号」存在模映射关系，因此也称为模映射（module mapping），即 cache 行（槽）号 = 主存块号 mod cache 行数。`
    ),
    section('全相联映射 cache（fully associative cache）')(
        p`全相联映射是指每个主存块可装入 cache 任一行的槽中。每个 cache 行的标志字段指出了该行的数据信息取自主存的哪个块。`
    ),
    section('组相联映射 cache（set-associative cache）')(
        p`组相联映射结合了直接映射和全相联映射的特点，将 cache 所有行分组，把一个主存块映射到特定 cache 组的任意一行中，即组间模映射、组内全映射。其映射关系为：cache 组号 = 主存块号 mod cache 组数。`
    ),
    section('多级 cache（multilevel cache）')(
        p`在计算机系统中，同时使用多个层次的 cache。例如，在 CPU 和主存之间设置两级 cache：L1 cache 和 L2 cache。一般 L1 cache 是数据 cache 和代码 cache 分离的。`
    ),
    section('数据 cache（data cache）')(p`专门用来存放数据信息的高速缓冲存储器称为数据 cache。`),
    section('代码 cache（code cache）')(p`专门用来存放指令代码的高速缓冲存储器称为代码 cache，也称为指令 cache。`),
    section('分离式 cache（split cache）')(p`在分离式 cache 中，数据和指令分开存放在各自的数据 cache 和指令 cache 中。`),
    section('先进先出（First-In-First-Out，FIFO）')(p`先进先出是一种替换算法，其基本思想是，总是把最先调入 cache 的一个主存块替换出去。`),
    section('最近最少用（Least Recently Used，LRU）')(p`最近最少用是一种替换算法，其基本思想是，总是把最近最少用的一个主存块从 cache 中替换出去。`),
    section('直写（write through）')(
        p`直写是指每次写 cache 的同时也写主存，使主存与 cache 始终保持一致性。这种方式比较简单，能保持主存与 cache 副本的一致性，但要插入慢速的访存操作，而且有些写入过程有可能是不必要的，例如中间结果的写入操作。这种方式的中文说法较多，有全写、直写、写直达、通过式写、透写等。`
    ),
    section('写缓冲（write buffer）')(
        p`在使用直写方式处理写操作时，为了减少每次写主存的时间，在 cache 和主存之间加一个写缓冲。这样就不必每次都写主存，而只要写到一个快速的写缓冲即可。当发生一次写操作时，CPU 同时写 cache 和写缓冲，然后由存储控制器将写缓冲内容写到主存。`
    ),
    section('回写（write back）')(
        p`回写是指每次写操作时，先暂时只写 cache，并用标志（dirty bit）予以注明，直到该块内容需从 cache 中替换出去时，才一次写入主存。这种方式不在写 cache 中插入慢速的写主存操作，可以保持程序运行的快速性。但在写回主存前，若主存与 cache 内容不一致，则会导致主存内容失效。这种方式的中文说法较多，有写回、回写、一次性写等。`
    ),
    section('关联度（associativity）')(
        p`关联度是指一个主存块映射到 cache 中时可能存放的位置个数。显然，直接映射的关联度为 1；全相联映射的关联度最高——为 cache 总行数；N 路组相联的关联度居中——为 N。`
    ),
    section('虚拟存储器（virtual memory）')(
        p`虚拟存储器是一种存储管理机制，在采用虚拟存储器的系统中，每个作业运行时，可以只装入当前执行到的一部分到内存，而让暂时执行不到的另一部分放在磁盘上，当需要用到时再从磁盘装入主存，这样使得在很小的主存空间能运行一个比它大的作业，而且用户编写程序时用到的逻辑地址空间可以比主存地址空间大。对用户来说，这就好像计算机系统具有一个容量很大的主存储器。`
    ),
    section('物理存储器（physical memory）')(p`通常把主存储器称为物理存储器。`),
    section('虚拟地址（virtual address）')(
        p`通常把用户编写程序时所用的地址称为虚拟地址或逻辑地址。每个程序都在同一个虚拟地址空间中编写程序。虚拟地址的位数确定了虚拟地址空间的大小。例如，如果虚拟地址为 32 位，按字节编址，则虚拟地址空间大小为 232 字节 =4GB。`
    ),
    section('虚页号（Virtual Page Number，VPN）')(
        p`为了实现虚拟存储器，通常把虚拟地址空间划分为若干等长的块，每块称为一页（page）。操作系统在加载程序时，按页为单位进行内存分配。每页按顺序进行编号，从第 0 页开始。虚拟地址空间所包含的页数决定了虚页号的位数，虚拟地址的高位部分为虚页号。`
    ),
    section('页内偏移量（page offset）')(
        p`页内偏移量是指需访问的逻辑地址位于当前页的哪个位置。页面大小决定了页内偏移量的位数，例如，如果一个虚拟页的大小为 2K（=211）字节，按字节编址，那么，页内偏移量就是 11 位。它为虚拟地址的低位部分。`
    ),
    section('物理地址（physical address）')(p`主存储器地址称为物理地址，也称主存地址或实地址。`),
    section('页框（page frame）')(
        p`有些书把页框（有时也翻译为「页帧」）称为物理页或实页。操作系统在管理内存时，按页为单位进行内存分配。其具体做法就是，把主存储器分成固定长且比较小的存储块，称为页框，每个进程也被划分成等长的程序块。这样，对进程进行存储分配时，将一个程序块（即虚拟页）装到一个可用的存储块（页框）中。`
    ),
    section('物理页号（Physical Page Number，PPN）')(
        p`把主存空间分成固定长的页框，从 0 开始按顺序编号，该编号就是物理页号，也称为页框号或实页号。物理地址的高位部分是物理页号。`
    ),
    section('地址变换（address translation/memory mapping）')(p`把程序中的虚拟地址转换为物理地址的过程称为地址变换。`),
    section('重定位（relocation）')(
        p`在采用虚拟存储器的系统中，程序员都在一个同样的虚拟地址空间中写程序。在程序装入系统运行时，操作系统按照某种存储管理机制（分段、分页、段页）把用户程序的一部分或全部放到内存中，并把存放的物理地址信息记录到段表或页表中，以建立虚拟地址空间和物理地址空间的映射。实现这种映射的过程称为程序重定位，它建立了逻辑地址和物理地址的映射关系，实现了逻辑地址向物理地址的转换。所以，重定位和地址转换是同一个概念。`,
        p`重定位方式有两种：一种方式通过链接程序或加载程序进行地址转换而实现程序重定位，这种方式下，程序执行时每条指令中的地址已经是物理地址，称为静态重定位；另一种方式是在程序执行过程中由硬件实现地址转换，称为动态重定位。`
    ),
    section('页表（page table）')(
        p`每个进程有一个页表，记录该进程的每个页存放在主存的哪个页框中，或在辅存哪个地方。页表中一般有装入位、修改位、替换控制位、访问控制位、实页号等。`
    ),
    section('页表基址寄存器（page table base register）')(
        p`每个进程有一个页表，页表在主存中的首地址被记录在一个特殊的寄存器中，这个特殊寄存器被称为页表基址寄存器，简称页表寄存器。`
    ),
    section('有效位（valid bit）')(
        p`有效位用来表示对应页是否装入主存并有效，也称为装入位。若该位为「1」，表示该页在主存中并且没有被淘汰；若该位为「0」，则说明该页不在主存，发生了「缺页」异常。`
    ),
    section('修改位（modify bit）')(
        p`修改位用来表示对应页在主存期间是否被修改过。若该位为「1」，则表明该页已被修改过，淘汰时必须将该页写回到磁盘。若该位为「0」，则表明该页未被修改过，淘汰时不需要将该页写回到磁盘。有些作者或系统把它称为「脏位（dirty bit）」。`
    ),
    section('使用位（reference bit/use bit）')(
        p`使用位用来表示对应页的使用情况，据此可以了解该页是最近经常被访问还是很少被访问，进而决定是否马上被替换。所以，使用位也称为替换控制位。`
    ),
    section('访问方式位（access bit）')(
        p`访问方式位用来表示该页的读写权限。例如，代码段所在页的访问方式一般是「执行/只读」；共享数据段所在页一般是「只读」；私有数据段所在页一般是「可读可写」。访问方式位也称为访问控制位或存取权限位。`
    ),
    section('缺页（page fault）')(p`若需要访问的页不在内存中，则发生「缺页」异常。通过检查「有效位」就可以判断是否「缺页」。`),
    section('交换（swapping）/页面调度（paging）')(
        p`缺页时，需要把所缺页面从磁盘调到主存中，这个过程称为「页面换入」（或磁盘调入）；当需要从主存淘汰一页到磁盘时，称为「页面换出」（或调出磁盘）。页面换入/换出称为交换（swapping）或页面调度（paging）。`
    ),
    section('按需调度页面（demand paging）')(p`只有发生「缺页」时才换入页面。大部分现代计算机系统都使用这种策略进行存储管理。`),
    section('LRU 页（Least Recently Used page）')(p`LRU 页是指最近最少使用的页。通过检查「使用位」可以找到 LRU 页。`),
    section('快表（Translation Lookaside Buffer，TLB）')(
        p`通常用一个特殊的 cache 来跟踪记录最近用过的页表表项。因为页表表项主要用于地址转换，所以把这种特殊的 cache 称为转换后援缓冲器。因为在 TLB 中查找页表项，速度很快，所以 TLB 也被称为快表。TLB 通常很小，在高端机器中也通常不超过 128～256 项，一般用全相联方式，中等性能机器多用小的组相联方式。`
    ),
    section('分页式虚拟存储器（Paging VM）')(
        p`分页式虚拟存储器的主要思想是，把主存储器分成固定长且比较小的存储块（称为页框，page frame），把虚拟地址空间也划分成等长的程序块（称为页，page）。操作系统把当前用到的页装入空闲的主存存储块中，所以分页方式是按固定长的页进行分配和调度的。逻辑地址由页号和页内偏移量组成。`
    ),
    section('分段式虚拟存储器（Segmentation VM）')(
        p`分段式虚拟存储器与分页式不同。分页式使用固定大小的块进行管理，而分段式采用变长块的机制管理存储器。「段」是按照程序的逻辑结构划分而成的多个相对独立的部分。例如，过程、子程序、数据表、阵列等。操作系统在进行虚拟空间和主存空间对应时，按程序中实际的段来分配主存空间，每个段在主存中的起始位置记录在段表中，并附以「段长」项。段表本身也是主存中的一个可再定位段。一个大程序由多个代码段和多个数据段构成。逻辑地址由段号和段内地址组成。`
    ),
    section('段页式虚拟存储器（Paged Segmentation VM）')(
        p`段页式是指分段和分页相结合的方式。程序按独立模块分段，段内再分成固定大小的页，主存分配时仍以页为基本单位。用段表和页表（每段一个）进行两级定位管理。逻辑地址由段地址、页地址和偏移量三个字段构成。根据段地址到段表中查阅与该段相应的页表指针，转向页表，然后根据页地址从页表中查到该页在主存中的实页号，与偏移量相加得到物理地址。`
    ),
    section('进程（Process）')(
        p`进程是程序在系统中某个数据集合上的一次动态运行。当运行一个程序时，就启动了一个进程，同一个程序在不同的数据集上运行构成不同的进程。进程是操作系统进行资源分配的单位。当某一个进程占用 CPU 执行，则该进程是活动进程（active process），否则是非活动进程（inactive process）。`
    ),
    section('管理模式（supervisor mode）')(
        p`管理模式有时也称为系统模式、内核模式、超级用户模式、管态、内核态、核心态。在管理模式下，处理器运行内核代码，允许使用特权指令，例如停机指令、开/关中断指令、cache 冲刷指令等。`
    ),
    section('用户模式（user Mode）')(p`用户模式也称目态、用户态。在用户模式下，处理器运行用户进程，此时不允许使用特权指令。`),
    section('系统调用（system call）')(
        p`系统调用用于使 CPU 从用户态转换到内核态。系统调用是一条专门的特殊指令，执行后，CPU 就调出特定的操作系统内核模块进行执行，进入内核态。在内核态下，操作系统可以执行专门的管态指令（或称特权指令，用户程序不能使用这些指令）来对一些用户进程不能访问的 CPU 状态进行读写。`
    ),
    section('异常返回（return from exception）')(
        p`异常返回指令用于从操作系统内核进程返回到用户进程。通过系统调用进入操作系统内核时，需保留系统调用指令后面一条指令的地址作为返回地址，所以用异常返回指令返回用户进程时，可以根据该地址进行返回。`
    ),
    section('存储保护（protection）')(
        p`虚拟存储器可以实现多道程序运行，也就是说，在一个主存物理空间中同时有多个进程共存。为避免主存中多道程序相互干扰，防止因某进程出错而破坏其他进程的正确性，或某进程不合法地访问其他进程的存储区，应对每个进程进行存储保护。存储保护应用于两类情况：① 地址越界，即访问了不该访问的区域；② 访问越权，即进行了不该进行的存取操作。`
    )
).elem
