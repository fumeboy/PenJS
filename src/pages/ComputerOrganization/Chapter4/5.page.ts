import { img, p, section } from '@src/components/@write'
import { multipleChoice, answer } from '@src/components/@questionnaire'
import pic4_5_1 from './4-5-1.jpg'
import pic4_5_2 from './4-5-2.jpg'
import pic4_5_3 from './4-5-3.jpg'
import pic4_5_4 from './4-5-4.jpg'
import pic4_5_5 from './4-5-5.jpg'
const title = '4.5　单项选择题'
const page = section(title)(
    multipleChoice('1.以下有关使用 GCC 生成 C 语言程序的可执行文件的叙述中，错误的是')(
        p`第一步预处理，对#include、#define、#ifdef 等预处理命令进行处理`,
        answer(p`第二步编译，将预处理结果编译转换为二进制形式的汇编语言程序代码`),
        p`第三步汇编，将汇编语言代码汇编转换为机器指令表示的机器语言代码`,
        p`第四步链接，将多个模块的机器语言代码链接生成可执行目标程序文件`
    ),
    multipleChoice('2.以下有关使用 GCC 生成 C 语言程序的可执行文件的叙述中，错误的是')(
        p`预处理的结果还是一个 C 语言源程序文件，属于可读的文本文件`,
        p`经过预处理、编译和汇编处理的结果是一个可重定位目标文件`,
        p`每个 C 语言源程序文件生成一个对应的可重定位目标文件`,
        answer(p`只要在链接命令中指定所有的相关可重定位目标文件，就能生成可执行文件`)
    ),
    multipleChoice('3.以下有关链接所带来的好处和不足的叙述中，错误的是')(
        p`使得程序员可以分模块开发程序，有利于提高大规模程序的开发效率`,
        p`使得公共函数库可以为所有程序共享使用，有利于代码重用和提高效率`,
        p`使得程序员仅需重新编译修改过的源程序模块，从而节省程序开发时间`,
        answer(p`使得所生成的可执行目标代码中包含了更多公共库函数代码，所占空间大`)
    ),
    multipleChoice('4.以下关于 ELF 目标文件格式的叙述中，错误的是')(
        p`可重定位目标文件是 ELF 格式的链接视图，由不同的节组成`,
        p`可执行目标文件是 ELF 格式的执行视图，由不同的段组成`,
        answer(p`可重定位和可执行两种目标文件中的数据都是二进制表示的补码形式`),
        p`可重定位和可执行两种目标文件中的代码都是二进制表示的指令形式`
    ),
    multipleChoice('5.以下关于链接器基本功能的叙述中，错误的是')(
        p`将每个符号引用与唯一的一个符号定义进行关联`,
        p`将每个.o 文件中的.data 节、.text 节和.bss 节分别合并`,
        answer(p`确定每个符号（包括全局变量和局部变量）的首地址`),
        p`根据所定义符号的首地址对符号的引用进行重定位`
    ),
    multipleChoice('6.以下关于可重定位目标文件的叙述中，错误的是')(
        p`在.text 节中包含相应模块内所有机器代码`,
        answer(p`在.data 节中包含相应模块内所有变量的初始值`),
        p`在.rodata 节中包含相应模块内所有只读数据`,
        p`在.rel.text 节和.rel.data 节中包含相应节内所有可重定位信息`
    ),
    multipleChoice('7.以下关于 ELF 目标文件的 ELF 头的叙述中，错误的是')(
        answer(p`包含了 ELF 头本身的长度和目标文件的长度`),
        p`包含了操作系统版本和机器结构类型等信息`,
        p`包含了节头表和程序头表各自的起始位置和长度`,
        p`数据结构在可重定位和可执行两种目标文件中完全一样`
    ),
    multipleChoice('8.以下关于 ELF 目标文件的节头表的叙述中，错误的是')(
        answer(p`每个表项用来记录某个节的内容以及相关描述信息`),
        p`通过节头表可获得节的名称、类型、起始地址和长度`,
        p`描述了每个可装入节的起始虚拟地址、对齐和存取方式`,
        p`数据结构在可重定位和可执行两种目标文件中完全一样`
    ),
    multipleChoice('9.以下关于 ELF 可重定位和可执行两种目标文件格式比较的叙述中，错误的是')(
        p`可重定位目标文件中有可重定位节.rel.text 和.rel.data，在可执行目标文件中则没有`,
        answer(p`可重定位目标文件中有初始化程序段.init 节，在可执行目标文件中则没有`),
        p`可执行目标文件中有程序头表（段头表），在可重定位目标文件中则没有`,
        p`可执行目标文件的 ELF 头中有具体程序入口地址，在可重定位目标文件中则为 0`
    ),
    multipleChoice('10.以下关于 ELF 可执行目标文件的程序头表（段头表）的叙述中，错误的是')(
        answer(p`用于描述可执行文件中的节与主存储器中的存储段之间的映射关系`),
        p`通过段头表可获得可装入段或特殊段的类型、在文件中的偏移位置及长度`,
        p`描述了每个可装入段的起始虚拟地址、存储长度、存取方式和对齐方式`,
        p`.text 节和.rodata 节都包含在只读代码段，而.data 节和.bss 节都包含在读写数据段`
    ),
    multipleChoice('11.以下关于链接过程中对符号定义的判断中，错误的是')(
        p`全局变量声明「int x，y；」中，x 和 y 都是符号的定义`,
        answer(p`全局变量声明「int*xp=&x；」中，xp 和 x 都是符号的定义`),
        p`静态局部变量声明「static int x=*xp；」中，x 是符号的定义`,
        p`函数内的局部变量声明「short x=200；」中，x 不是符号的定义`
    ),
    multipleChoice('12.若 x 为局部变量，xp、y 和 z 是全局变量，则以下判断中错误的是')(
        answer(p`赋值语句「int y=x+z；」中，y 和 z 都是符号的引用`),
        p`赋值语句「y=x+z；」中，y 和 z 都是符号的引用`,
        p`静态局部变量声明「static int x=*xp；」中，xp 是符号的引用`,
        p`赋值语句「y=x+*xp；」中，y 和 xp 都是符号的引用`
    ),
    multipleChoice('13.以下有关链接符号类型的叙述中，错误的是')(
        p`由模块 m 定义并能被其他模块引用的符号称为 m 的全局符号`,
        p`由其他模块定义并被模块 m 引用的符号称为 m 的外部符号`,
        p`由模块 m 定义并仅在 m 中引用的符号称为 m 的本地符号`,
        answer(p`在模块 m 内的某个函数中定义的局部变量称为 m 的局部符号`)
    ),
    multipleChoice('14.以下有关 ELF 目标文件的符号表的叙述中，错误的是')(
        p`可重定位和可执行两种目标文件中都有符号表且数据结构一样`,
        p`符号表定义在.symtab 节中，每个表项描述某个符号的相应信息`,
        p`通过符号表可获得符号的名称、所在节及在节中偏移地址和长度`,
        answer(p`符号表中包含了所有定义符号的描述信息，包括局部变量的相关信息`)
    ),
    multipleChoice('15.以下是有关链接过程中符号解析（符号绑定）的叙述，错误的是')(
        p`符号解析的目的是将符号引用与某目标模块中定义的符号建立关联`,
        answer(p`同一个符号名可能在多个模块中有定义，每个定义处的符号都须分配空间`),
        p`本地符号的解析比较简单，只要与本模块内定义的符号关联即可`,
        p`全局符号（包括外部符号）需将模块内的引用与模块外的定义符号绑定`
    ),
    multipleChoice('16.以下有关强符号和弱符号定义的叙述中，错误的是')(
        p`局部符号没有强、弱符号的概念`,
        answer(p`所有出现的函数名都是强符号`),
        p`没有初始化的全局变量名是弱符号`,
        p`已初始化的全局变量名是强符号`
    ),
    multipleChoice('17.以下有关强符号和弱符号的符号解析的叙述中，错误的是')(
        p`一个符号名只能有一个强符号，否则符号解析失败`,
        p`一个符号名可以有多个弱符号，任选一个为其定义`,
        p`一个符号名可以有一个强符号和多个弱符号，强符号为其定义`,
        answer(p`一个符号名可以仅出现在引用处或仅出现在定义处`)
    ),
    multipleChoice('18.以下是两个源程序文件：',img(pic4_5_1)(), p`对于上述两个源程序文件链接时的符号解析，错误的是`)(
        p`在 m1 中，定义了一个强符号 main 和一个弱符号 p`,
        p`在 m2 中，定义了一个强符号 p 和一个本地符号 main`,
        p`在 m1 中，对 m2 中定义的强符号 p 的引用只有一处`,
        answer(p`因为出现了两个强符号 main，所以会发生链接错误`)
    ),
    multipleChoice('19.以下是两个源程序文件：',img(pic4_5_2)(), p`对于上述两个源程序文件链接时的符号解析，错误的是`)(
        p`在 m1 中，定义了一个强符号 main 和一个弱符号 p`,
        p`在 m2 中，定义了一个强符号 p 和一个强符号 main`,
        answer(p`在模块 m1 的所有语句中，对符号 p1 的引用共有两处`),
        p`因为出现了两个强符号 main，所以会发生链接错误`
    ),
    multipleChoice('20.以下是两个源程序文件：',img(pic4_5_3)(), p`对于上述两个源程序文件链接时的符号解析，错误的是`)(
        p`m1 中对 x 的两处引用都与 m1 中对 x 的定义绑定`,
        answer(p`m2 中对 x 的引用与 m2 中对 x 的定义绑定`),
        p`m2 中的变量 p1 与函数 p1 被分配在不同存储区`,
        p`虽然 x、main 和 p1 都出现了多次定义，但不会发生链接错误`
    ),
    multipleChoice('21.以下是两个源程序文件：',img(pic4_5_4)(),img(pic4_5_5)(), p`上述程序执行的结果是（提示：1074790400=230+220，16400=214+24。）`)(
        p`x=100，z=2`,
        p`x=-1，z=2`,
        p`x=-1074790400，z=0`,
        answer(p`x=0，z=-16400`)
    ),
    multipleChoice(
        '22.假设调用关系如下：func.o→libx.a 和 liby.a 中的函数，libx.a→libz.a 中的函数，libx.a 和 liby.a 之间、liby.a 和 libz.a 相互独立，则以下几个命令行中，静态链接发生错误的命令是'
    )(
        p`gcc-static-o myfunc func.o libx.a liby.a libz.a`,
        answer(p`gcc-static-o myfunc func.o liby.a libz.a libx.a`),
        p`gcc-static-o myfunc func.o libx.a libz.a liby.a`,
        p`gcc-static-o myfunc func.o liby.a libx.a libz.a`
    ),
    multipleChoice(
        '23.假设调用关系如下：func1.o→func2.o，func1.o→libx.a 中的函数，func2.o→libx.a 中的函数，libx.a→liby.a 同时 liby.a→libx.a，则以下命令行中，能够正确进行静态链接的命令是'
    )(
        answer(p`gcc-static-o myfunc func1.o func2.o libx.a liby.a libx.a`),
        p`gcc-static-o myfunc func2.o func1.o liby.a libx.a liby.a`,
        p`gcc-static-o myfunc libx.a liby.a libx.a func1.o func2.o`,
        p`gcc-static-o myfunc liby.a libx.a liby.a func1.o func2.o`
    ),
    multipleChoice('24.以下有关重定位功能的叙述中，错误的是')(
        p`重定位的最终目标是重新确定各模块合并后每个引用所指向的目标地址`,
        p`重定位的第一步应先将相同的节合并，且将具有相同存取属性的节合并成段`,
        p`重定位的第二步是确定每个段的起始地址，并确定段内每个定义处符号的地址`,
        answer(p`重定位的最后一步是将引用处的地址修改为与之关联（绑定）的定义处的首地址`)
    ),
    multipleChoice('25.以下有关重定位信息的叙述中，错误的是')(
        answer(p`重定位信息是由编译器在生成汇编指令时产生的`),
        p`指令中的重定位信息在可重定位目标文件的.rel.text 节中`,
        p`数据中的重定位信息在可重定位目标文件的.rel.data 节中`,
        p`重定位信息包含需要重定位的位置、绑定的符号和重定位类型`
    ),
    multipleChoice('26.以下有关 IA-32 的重定位类型的叙述中，错误的是')(
        p`基本重定位类型有绝对地址和 PC 相对地址两种方式`,
        p`对于过程调用中的引用，通常在 CALL 指令中采用 PC 相对地址方式`,
        p`PC 相对地址指引用所绑定符号的地址与当前 PC 的相对地址是重定位值`,
        answer(p`过程调用相关的重定位中，PC 相对地址中使用的当前 PC 是指 CALL 指令的地址`)
    ),
    multipleChoice(
        '27.假定「int buf[2]={10，50}；」所定义的 buf 被分配在静态数据区，其首地址为 0x8048930，bufp1 为全局变量，被分配在 buf 随后的存储空间。以下关于「int*bufp1=&buf[1]；」的重定位的描述中，错误的是'
    )(
        p`bufp1 的地址为 0x8048938，重定位前的内容为 04H、00H、00H、00H`,
        p`在可重定位目标文件的.rel.data 节中，有一个引用 buf 的重定位条目`,
        answer(p`在相应的重定位条目中，对 bufp1 和 buf 的引用均采用绝对地址方式`),
        p`在可执行目标文件中，地址 0x8048938 开始的 4 个字节为 34H、89H、04H、08H`
    ),
    multipleChoice(
        '28.假定「int buf[2]={10，50}；」所定义的 buf 被分配在静态数据区，其首地址为 0x8048930，bufp1 为全局变量，也被分配在静态数据区。以下关于「bufp1=&buf[1]；」的重定位的描述中，错误的是'
    )(
        answer(p`在可重定位目标文件的.rel.data 节中，有一个与 bufp1 相关的重定位条目`),
        p`在可重定位目标文件的.rel.text 节中，有一个与 buf 相关的重定位条目`,
        p`在相应的重定位条目中，对 bufp1 和 buf 的引用均采用绝对地址方式`,
        p`可用一条 mov 指令实现该赋值语句，该 mov 指令中有两处需要重定位`
    ),
    multipleChoice('29.以下有关在 Linux 系统中启动可执行目标文件执行的叙述中，错误的是')(
        answer(p`可在 CUI（命令行用户界面）中双击可执行目标文件对应的图标来启动其执行`),
        p`可在 CUI（命令行用户界面）中的命令行提示符后输入对应的命令来启动其执行`,
        p`可以通过在一个程序中调用 execve（）系统调用函数来启动可执行文件执行`,
        p`不管是哪种启动执行方式，最终都是通过调用 execve（）系统调用函数实现的`
    ),
    multipleChoice('30.以下有关在 Linux 系统中加载可执行目标文件的叙述中，错误的是')(
        p`可执行目标文件的加载通过 execve（）函数调用的加载器来完成`,
        p`加载器通过可执行目标文件中的程序头表对可装入段进行加载`,
        answer(p`在可执行目标文件的加载过程中，其中的指令和数据被读入主存储器`),
        p`任何可执行目标文件中的可装入段被映射到一个统一的虚拟地址空间`
    ),
    multipleChoice(
        '31.以下是在 Linux 系统中启动并加载可执行目标文件过程中 shell 命令行解释程序所做的部分操作：',
        p`① 构造 argv 和 envp`,
        p`② 调用 fork（）系统调用函数`,
        p`③ 调用 execve（）系统调用函数`,
        p`④ 读入命令（可执行文件名）及参数`,
        p`启动并加载可执行目标文件的正确步骤是`
    )(p`①→②→③→④`, p`②→④→①→③`, answer(p`④→①→②→③`), p`④→①→③→②`),
    multipleChoice('32.以下有关动态链接及其所链接的共享库以及动态链接生成的可执行目标文件的叙述中，错误的是')(
        p`共享库在 Linux 下称为动态共享对象（.so），在 Windows 下称为动态链接库（.dll）`,
        p`生成的可执行目标文件是部分链接的，也即其中还有部分引用没有进行重定位`,
        answer(p`可执行目标文件由动态链接器对可重定位目标文件和共享库中部分信息进行链接而成`),
        p`可执行目标文件在加载或执行时，系统将会调出动态链接器利用共享库对其进行动态链接`
    ),
    multipleChoice('33.以下有关静态链接和动态链接比较的叙述中，错误的是')(
        p`静态库函数代码包含在进程代码段中，而共享库函数代码不包含在进程代码段中`,
        p`静态库函数代码包含在可执行目标文件中，而共享库函数代码不包含在可执行目标文件中`,
        p`静态库函数更新后需对程序重新编译和链接，而共享库函数更新后程序无需重新编译和链接`,
        answer(p`静态库函数在加载时被链接，而共享库函数可在加载或运行时被链接`)
    ),
    multipleChoice('34.以下有关动态链接所用共享库代码的叙述中，错误的是')(
        p`共享库代码一定是位置无关代码（PIC）`,
        p`用 GCC 生成共享库文件时应使用-fPIC 选项`,
        p`链接器可将共享库代码映射到不同的地址运行`,
        answer(p`共享库代码长度发生变化时会影响调用它的程序`)
    ),
    multipleChoice(
        '35.一个共享库文件（.so 文件）由多个模块（.o 文件）生成。在生成共享库文件的过程中，需要对.o 文件进行处理，以生成位置无关代码。以下有关位置无关代码（PIC）生成的叙述中，错误的是'
    )(
        p`模块内函数之间的调用可用 PC 相对地址实现，无需动态链接器进行重定位`,
        p`模块内数据的引用无需动态链接器进行重定位，因为引用与定义间相对位置固定`,
        p`模块外数据的引用需要动态链接器进行重定位，重定位时在 GOT 中填入外部数据的地址`,
        answer(p`模块间函数调用需要动态链接器进行重定位，重定位时在 GOT 和 PLT 中填入相应内容`)
    ),
    section('部分题目的答案解析')(
        section('第 21 题')(
            p`该题中变量 x 在 m1.c 中为强符号，在 m2.c 中为弱符号。在调用 p1 函数后，x 处原来存放的 100 被替换，-1.0 的 double 类型表示为 10111111111100…0，十六进制表示为 BFF0000000000000。因为 x、y 和 z 都是初始化变量，同在.data 节中，链接后空间被分配在一起，x 占 4B，随后 y 和 z 各占 2B。因为 IA-32 为小端方式，所以 x 的机器数为全 0，y 的机器数也为全 0，z 的机器数为 BFF0H。执行 printf 函数后 x=0，z=-（214+24）=-16400。`
        ),
        section('第 24 题')(
            p`重定位的最后一步是对引用处的地址进行重定位，重定位的方式有多种，只有绝对地址方式才是将引用处的地址修改为与之关联（绑定）的定义处的首地址，而其他重定位方式就不一定是这样，例如，对于 PC 相对地址方式，引用处填写的是一个相对地址。`
        ),
        section('第 25 题')(
            p`重定位信息应该是在汇编阶段生成的，只有在汇编阶段生成机器指令时才知道需要进行重定位的位置，因为这些需要重定位的位置在机器指令中，例如，CALL 指令中的偏移地址等。`
        ),
        section('第 26 题')(p`CALL 指令中的重定位采用 PC 相对地址方式，其中当前 PC 是指 CALL 指令的下一条指令的地址，而不是 CALL 指令的地址。`),
        section('第 27 题')(
            p`选项 A：因为 buf 有 2 个数组元素，每个元素占 4B，因此 bufp1 的地址为 0x8048930+8=0x8048938，重定位时与引用绑定的符号是 buf，即绑定的是&buf[0]，而真正赋给 bufp1 的是&buf[1]，引用的地址和绑定的地址相差 4，所以重定位前的内容为十六进制数 04000000。`,
            p`选项 B：因为「int*bufp1=&buf[1]；」是一个声明，也即对变量 bufp1 的数据类型的定义和初始化，所以这个需要重定位的初始化值将被存储在.data 节中，因而重定位条目在.rel.data 节中，并且是绑定 buf 的一个引用，即引用 buf 的一个重定位条目。`,
            p`选项 C：在重定位条目中只有对 buf 的引用，没有对 bufp1 的引用，这里 bufp1 是一个定义。`,
            p`选项 D：可执行文件已经进行了重定位，所以 bufp1 所在的地址 0x8048938 处，应该是重定位后的值，显然应该是 buf[1]的地址。重定位时通过初始值加上 buf 的值得到，即 4+0x8048930=0x8048934，小端方式下，4 个字节分别为 34H、89H、04H、08H。`
        ),
        section('第 28 题')(
            p`选项 A：因为「bufp1=&buf[1]；」是一个赋值语句，而不是一个声明，所以不需要对.data 节中的 bufp1 变量进行重定位，也即重定位条目不在.rel.data 节中。`,
            p`选项 B：赋值语句「bufp1=&buf[1]；」用 movl 指令可以实现，所以，对 buf 的引用出现在机器代码中，即.text 节中，因而重定位条目在.rel.text 节中。`,
            p`选项 C：赋值语句「bufp1=&buf[1]；」用 movl 指令可以实现，其源操作数和目的操作数都是绝对地址方式。`,
            p`选项 D：赋值语句「bufp1=&buf[1]；」用 movl 指令可以实现，其源操作数和目的操作数都需要重定位。`
        )
    )
).elem
